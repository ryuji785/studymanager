import React, { useEffect, useMemo, useState } from 'react';
import { differenceInCalendarDays, parseISO } from 'date-fns';
import { toast } from 'sonner';

import type { AppData, Category, LifestyleBlock, LifestyleTemplate, PlanItem, PlanWeek, WeeklyGoal } from '../types';
import { createDefaultLifestyleTemplate } from '../data/appDataStore';
import { formatMinutes, minutesToTimeString, timeStringToMinutes } from '../utils/time';
import { AppChrome } from './layout/AppChrome';
import { type PeriodValue } from './ui/period-selector';
import { Button } from './ui/button';
import { PageLayout } from './ui/page-layout';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from './ui/dialog';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { LifestyleForm } from './LifestyleForm';
import { BlockSheet } from './weekly/BlockSheet';
import { ScheduleView } from './weekly/ScheduleView';
import { WeekSummary } from './weekly/WeekSummary';
import { useMediaQuery } from '../hooks/useMediaQuery';
import { CATEGORY_COLOR_POOL } from '../utils/categoryColors';

type AutoGenerateMode = 'append' | 'replace';

const DAYS: Array<{ value: number; label: string }> = [
  { value: 0, label: '月' },
  { value: 1, label: '火' },
  { value: 2, label: '水' },
  { value: 3, label: '木' },
  { value: 4, label: '金' },
  { value: 5, label: '土' },
  { value: 6, label: '日' },
];

function createDefaultWeeklyGoals(): WeeklyGoal[] {
  const base = Date.now();
  return Array.from({ length: 3 }).map((_, index) => ({
    id: `goal_${base}_${index}`,
    text: '',
    completed: false,
  }));
}

function weekIdFromStart(start: string) {
  return `week_${start.replace(/-/g, '')}`;
}

function getLifestyleDurationMinutes(startTime: number, endTime: number) {
  if (startTime === endTime) return 0;
  if (endTime < startTime) return endTime + 1440 - startTime;
  return endTime - startTime;
}

function buildLifestyleItems(weekId: string, template: LifestyleTemplate): PlanItem[] {
  const items: PlanItem[] = [];
  for (let day = 0; day < 7; day += 1) {
    const isWeekend = day === 5 || day === 6;
    const sleep = template.weekendEnabled && isWeekend && template.weekendSleep ? template.weekendSleep : template.weekdaySleep;
    const sleepDuration = getLifestyleDurationMinutes(sleep.startTime, sleep.endTime);
    if (sleepDuration > 0) {
      items.push({
        id: `lifestyle_sleep_${weekId}_${day}`,
        weekId,
        type: 'lifestyle',
        dayOfWeek: day,
        startTime: sleep.startTime,
        duration: sleepDuration,
        label: '睡眠',
        status: 'planned',
        isAutoGenerated: true,
      });
    }
  }

  template.optionalBlocks.forEach((block) => {
    const days = Array.isArray(block.daysOfWeek) ? Array.from(new Set(block.daysOfWeek)) : [];
    days.forEach((day) => {
      items.push({
        id: `lifestyle_optional_${weekId}_${block.id}_${day}`,
        weekId,
        type: 'fixed',
        dayOfWeek: day,
        startTime: block.startTime,
        duration: block.duration,
        categoryId: block.categoryId,
        label: block.label,
        status: 'planned',
        isAutoGenerated: true,
      });
    });
  });

  return items;
}

function getWeekLifestyleItemsFromData(data: AppData, weekId: string) {
  const weekItems = data.planItems.filter((item) => item.weekId === weekId);
  const overrides = weekItems.filter((item) => item.type !== 'study' && !item.isAutoGenerated);
  if (overrides.length > 0) return overrides;
  const template = data.lifestyleTemplate ?? createDefaultLifestyleTemplate();
  if (template.weekdaySleep.startTime === template.weekdaySleep.endTime) return [];
  return buildLifestyleItems(weekId, template);
}

function hashKey(value: string) {
  let hash = 0;
  for (let i = 0; i < value.length; i += 1) {
    hash = (hash << 5) - hash + value.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash).toString(36);
}

function buildTemplateFromWeekItems(
  weekItems: PlanItem[],
  fallback: LifestyleTemplate,
): LifestyleTemplate {
  const sleepItems = weekItems.filter((item) => item.type === 'lifestyle');
  const weekdaySleepItem =
    sleepItems.find((item) => item.dayOfWeek === 0) ??
    sleepItems.find((item) => item.dayOfWeek >= 0 && item.dayOfWeek <= 4) ??
    null;
  const weekendSleepItem =
    sleepItems.find((item) => item.dayOfWeek === 5) ??
    sleepItems.find((item) => item.dayOfWeek === 6) ??
    null;

  const weekdaySleep = weekdaySleepItem
    ? {
        startTime: weekdaySleepItem.startTime,
        endTime: (weekdaySleepItem.startTime + weekdaySleepItem.duration) % 1440,
      }
    : fallback.weekdaySleep;

  const weekendSleep = weekendSleepItem
    ? {
        startTime: weekendSleepItem.startTime,
        endTime: (weekendSleepItem.startTime + weekendSleepItem.duration) % 1440,
      }
    : fallback.weekendSleep;

  const weekendEnabled =
    Boolean(weekendSleepItem) &&
    (weekdaySleep.startTime !== weekendSleep?.startTime || weekdaySleep.endTime !== weekendSleep?.endTime);

  const fixedItems = weekItems.filter((item) => item.type === 'fixed');
  const blocks = new Map<string, LifestyleBlock>();

  fixedItems.forEach((item) => {
    const label = item.label ?? '固定予定';
    const key = `${label}|${item.startTime}|${item.duration}|${item.categoryId ?? ''}`;
    const id = `block_${hashKey(key)}`;
    const existing = blocks.get(key);
    if (existing) {
      if (!existing.daysOfWeek.includes(item.dayOfWeek)) {
        existing.daysOfWeek.push(item.dayOfWeek);
      }
      return;
    }
    blocks.set(key, {
      id,
      label,
      daysOfWeek: [item.dayOfWeek],
      startTime: item.startTime,
      duration: item.duration,
      categoryId: item.categoryId,
    });
  });

  return {
    ...fallback,
    weekdaySleep,
    weekendEnabled,
    weekendSleep: weekendEnabled ? weekendSleep ?? fallback.weekendSleep : undefined,
    optionalBlocks: Array.from(blocks.values()).sort((a, b) => a.startTime - b.startTime),
    updatedAt: new Date().toISOString(),
  };
}

function computeAvailableMinutes(template: LifestyleTemplate | undefined) {
  if (!template) return 0;
  const totalWeekMinutes = 7 * 24 * 60;
  let lifestyleMinutes = 0;
  for (let day = 0; day < 7; day += 1) {
    const isWeekend = day === 5 || day === 6;
    const sleep = template.weekendEnabled && isWeekend && template.weekendSleep ? template.weekendSleep : template.weekdaySleep;
    lifestyleMinutes += getLifestyleDurationMinutes(sleep.startTime, sleep.endTime);
  }
  lifestyleMinutes += template.optionalBlocks.reduce((sum, block) => {
    const count = Array.isArray(block.daysOfWeek) ? block.daysOfWeek.length : 0;
    return sum + block.duration * count;
  }, 0);
  return Math.max(0, totalWeekMinutes - lifestyleMinutes);
}

function computeAvailableMinutesFromItems(items: PlanItem[]) {
  const totalWeekMinutes = 7 * 24 * 60;
  const lifestyleMinutes = items.reduce((sum, item) => sum + item.duration, 0);
  return Math.max(0, totalWeekMinutes - lifestyleMinutes);
}

function computeCategoryTotals(items: PlanItem[]) {
  const totals = new Map<string, number>();
  items.forEach((item) => {
    if (!item.categoryId) return;
    const minutes = item.actualDuration ?? item.duration;
    totals.set(item.categoryId, (totals.get(item.categoryId) ?? 0) + minutes);
  });
  return totals;
}

function createCategory(name: string, usedColors: string[]): Category {
  const color = CATEGORY_COLOR_POOL.find((entry) => !usedColors.includes(entry)) ?? CATEGORY_COLOR_POOL[0];
  return {
    id: `cat_${Date.now()}`,
    name,
    color,
    createdAt: new Date().toISOString(),
  };
}

function roundToStep(minutes: number, step: number) {
  return Math.round(minutes / step) * step;
}

function generateAutoItems(params: {
  weekStart: string;
  weekId: string;
  materials: AppData['materials'];
}): PlanItem[] {
  const weekStartDate = parseISO(params.weekStart);
  const slots = [
    { dayOfWeek: 0, startTime: 19 * 60 },
    { dayOfWeek: 2, startTime: 19 * 60 },
    { dayOfWeek: 4, startTime: 19 * 60 },
    { dayOfWeek: 6, startTime: 10 * 60 },
    { dayOfWeek: 1, startTime: 20 * 60 },
    { dayOfWeek: 3, startTime: 20 * 60 },
    { dayOfWeek: 5, startTime: 10 * 60 },
  ];
  let slotIndex = 0;

  return params.materials.flatMap((material) => {
    const deadline = parseISO(material.deadline);
    const daysToDeadline = differenceInCalendarDays(deadline, weekStartDate);
    if (Number.isNaN(daysToDeadline) || daysToDeadline < 0) return [];

    const sessions = daysToDeadline <= 14 ? 2 : 1;
    return Array.from({ length: sessions }).map((_, idx) => {
      const slot = slots[slotIndex % slots.length];
      slotIndex += 1;
      return {
        id: `auto_${params.weekId}_${material.id}_${idx}`,
        weekId: params.weekId,
        type: 'study',
        dayOfWeek: slot.dayOfWeek,
        startTime: slot.startTime,
        duration: 60,
        categoryId: material.categoryId,
        materialId: material.id,
        label: material.name,
        status: 'planned',
        isAutoGenerated: true,
      } satisfies PlanItem;
    });
  });
}

export function WeeklyPlanPage({
  data,
  period,
  onChangePeriod,
  onUpdateData,
  onNavigateSettings,
  onNavigateMaterials,
}: {
  data: AppData;
  period: PeriodValue;
  onChangePeriod: (next: PeriodValue) => void;
  onUpdateData: (updater: (prev: AppData) => AppData) => void;
  onNavigateSettings: (focus?: 'goal') => void;
  onNavigateMaterials: () => void;
}) {
  const weekId = weekIdFromStart(period.start);
  const week = data.planWeeks.find((w) => w.weekStartDate === period.start);
  const weekItems = useMemo(() => data.planItems.filter((item) => item.weekId === weekId), [data.planItems, weekId]);
  const weekLifestyleOverrides = useMemo(
    () => weekItems.filter((item) => item.type !== 'study' && !item.isAutoGenerated),
    [weekItems],
  );
  const hasWeekLifestyleOverride = weekLifestyleOverrides.length > 0;
  const studyItems = weekItems.filter((item) => item.type === 'study');
  const doneItems = studyItems.filter((item) => item.status === 'done');
  const defaultGoals = useMemo(() => createDefaultWeeklyGoals(), [period.start]);
  const weekGoals = week?.goals ?? defaultGoals;

  const baseLifestyleTemplate = useMemo(
    () => data.lifestyleTemplate ?? createDefaultLifestyleTemplate(),
    [data.lifestyleTemplate],
  );
  const weekLifestyleTemplate = useMemo(() => {
    if (hasWeekLifestyleOverride) {
      return buildTemplateFromWeekItems(weekLifestyleOverrides, baseLifestyleTemplate);
    }
    return data.lifestyleTemplate;
  }, [hasWeekLifestyleOverride, weekLifestyleOverrides, baseLifestyleTemplate, data.lifestyleTemplate]);
  const lifestyleReady = Boolean(
    weekLifestyleTemplate &&
      weekLifestyleTemplate.weekdaySleep &&
      weekLifestyleTemplate.weekdaySleep.startTime !== weekLifestyleTemplate.weekdaySleep.endTime,
  );
  const lifestyleItems = weekLifestyleTemplate ? buildLifestyleItems(weekId, weekLifestyleTemplate) : [];
  const displayLifestyleItems = hasWeekLifestyleOverride ? weekLifestyleOverrides : lifestyleItems;
  const displayItems = lifestyleReady ? [...displayLifestyleItems, ...studyItems] : studyItems;

  const availableMinutes = hasWeekLifestyleOverride
    ? computeAvailableMinutesFromItems(displayLifestyleItems)
    : computeAvailableMinutes(weekLifestyleTemplate);
  const doneMinutes = doneItems.reduce((sum, item) => sum + (item.actualDuration ?? item.duration), 0);
  const plannedMinutes = studyItems.reduce((sum, item) => sum + item.duration, 0);
  const remainingAvailableMinutes = availableMinutes - plannedMinutes;
  const completionRate = plannedMinutes > 0 ? Math.round((doneMinutes / plannedMinutes) * 100) : 0;
  const progressValue = plannedMinutes > 0 ? Math.min(100, (doneMinutes / plannedMinutes) * 100) : 0;
  const remainingValue =
    plannedMinutes === 0
      ? '予定を入れると表示'
      : remainingAvailableMinutes >= 0
        ? formatMinutes(remainingAvailableMinutes)
        : `-${formatMinutes(Math.abs(remainingAvailableMinutes))}`;
  const remainingDisplay = lifestyleReady
    ? plannedMinutes === 0
      ? formatMinutes(availableMinutes)
      : remainingValue
    : '未設定';
  const completionLabel = plannedMinutes > 0 ? `${completionRate}%` : '—';
  const doneTotalDisplay = doneMinutes === 0 ? '0分' : formatMinutes(doneMinutes);
  const budgetTotalDisplay = lifestyleReady ? formatMinutes(availableMinutes) : '未設定';
  const budgetPlannedDisplay = plannedMinutes > 0 ? formatMinutes(plannedMinutes) : '未設定';
  const budgetRemainingRatio =
    availableMinutes > 0 ? Math.max(0, Math.min(1, remainingAvailableMinutes / availableMinutes)) * 100 : 0;
  const budgetOver = lifestyleReady && plannedMinutes > availableMinutes;

  const doneCategoryTotals = computeCategoryTotals(doneItems);
  const plannedCategoryTotals = new Map<string, number>();
  studyItems.forEach((item) => {
    if (!item.categoryId) return;
    plannedCategoryTotals.set(item.categoryId, (plannedCategoryTotals.get(item.categoryId) ?? 0) + item.duration);
  });
  const categorySummary = Array.from(plannedCategoryTotals.entries())
    .map(([categoryId, planned]) => ({
      category: data.categories.find((c) => c.id === categoryId),
      planned,
      done: doneCategoryTotals.get(categoryId) ?? 0,
    }))
    .filter((entry) => entry.category)
    .sort((a, b) => b.planned - a.planned);

  const todayIndex = useMemo(() => {
    const jsDay = new Date().getDay();
    return (jsDay + 6) % 7;
  }, []);

  const [itemSheetOpen, setItemSheetOpen] = useState(false);
  const [editingItem, setEditingItem] = useState<
    (Partial<PlanItem> & Pick<PlanItem, 'dayOfWeek' | 'startTime' | 'duration'>) | null
  >(null);
  const [autoDialogOpen, setAutoDialogOpen] = useState(false);
  const [autoMode, setAutoMode] = useState<AutoGenerateMode>('append');
  const [setupOpen, setSetupOpen] = useState(false);
  const [lifestyleDraft, setLifestyleDraft] = useState<LifestyleTemplate>(baseLifestyleTemplate);
  const [lifestyleItemOpen, setLifestyleItemOpen] = useState(false);
  const [todayPanelOpen, setTodayPanelOpen] = useState(true);
  const [editingLifestyleItem, setEditingLifestyleItem] = useState<PlanItem | null>(null);
  const [lifestyleStart, setLifestyleStart] = useState('00:00');
  const [lifestyleEnd, setLifestyleEnd] = useState('00:00');
  const [lifestyleLabel, setLifestyleLabel] = useState('');
  const [lifestyleCategoryId, setLifestyleCategoryId] = useState('none');
  const [selectedDay, setSelectedDay] = useState(todayIndex);
  const [lastTouchedTime, setLastTouchedTime] = useState<number | null>(null);
  const [lifestyleNoticeShown, setLifestyleNoticeShown] = useState(false);
  const isDesktop = useMediaQuery('(min-width: 1024px)');
  const isLifestyleTemplateMissing = !data.lifestyleTemplate;

  useEffect(() => {
    if (!setupOpen) return;
    if (weekLifestyleTemplate) {
      setLifestyleDraft(weekLifestyleTemplate);
      return;
    }
    setLifestyleDraft(baseLifestyleTemplate);
  }, [setupOpen, weekLifestyleTemplate, baseLifestyleTemplate]);

  useEffect(() => {
    if (!editingLifestyleItem) return;
    setLifestyleStart(minutesToTimeString(editingLifestyleItem.startTime));
    setLifestyleEnd(minutesToTimeString((editingLifestyleItem.startTime + editingLifestyleItem.duration) % 1440));
    setLifestyleLabel(
      editingLifestyleItem.type === 'fixed'
        ? editingLifestyleItem.label ?? '固定予定'
        : editingLifestyleItem.label ?? '睡眠',
    );
    setLifestyleCategoryId(editingLifestyleItem.categoryId ?? 'none');
  }, [editingLifestyleItem]);

  useEffect(() => {
    setSelectedDay(todayIndex);
  }, [period.start, todayIndex]);

  const ensureWeek = (
    prev: AppData,
    target?: { start: string; end: string },
  ): { next: AppData; week: PlanWeek } => {
    const start = target?.start ?? period.start;
    const end = target?.end ?? period.end;
    const targetId = weekIdFromStart(start);
    const existing = prev.planWeeks.find((w) => w.weekStartDate === start);
    if (existing) return { next: prev, week: existing };
    const now = new Date().toISOString();
    const nextWeek: PlanWeek = {
      id: targetId,
      weekStartDate: start,
      weekEndDate: end,
      createdAt: now,
      updatedAt: now,
      goals: defaultGoals,
    };
    return { next: { ...prev, planWeeks: [nextWeek, ...prev.planWeeks] }, week: nextWeek };
  };

  const touchWeek = (weeks: PlanWeek[], targetId: string) => {
    const now = new Date().toISOString();
    return weeks.map((w) => (w.id === targetId ? { ...w, updatedAt: now } : w));
  };

  const updateWeekGoals = (updater: (prevGoals: WeeklyGoal[]) => WeeklyGoal[]) => {
    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const currentGoals = ensured.week.goals ?? defaultGoals;
      const nextGoals = updater(currentGoals);
      const now = new Date().toISOString();
      return {
        ...ensured.next,
        planWeeks: ensured.next.planWeeks.map((w) =>
          w.id === ensured.week.id ? { ...w, goals: nextGoals, updatedAt: now } : w,
        ),
      };
    });
  };

  const handleGoalChange = (goalId: string, text: string) => {
    updateWeekGoals((prevGoals) => prevGoals.map((goal) => (goal.id === goalId ? { ...goal, text } : goal)));
  };

  const handleGoalToggle = (goalId: string) => {
    updateWeekGoals((prevGoals) =>
      prevGoals.map((goal) => (goal.id === goalId ? { ...goal, completed: !goal.completed } : goal)),
    );
  };

  const handleGoalAdd = () => {
    updateWeekGoals((prevGoals) => [
      ...prevGoals,
      {
        id: `goal_${Date.now()}`,
        text: '',
        completed: false,
      },
    ]);
  };

  const handleGoalDelete = (goalId: string) => {
    updateWeekGoals((prevGoals) => prevGoals.filter((goal) => goal.id !== goalId));
  };

  const openNewItemSheet = (dayOfWeek?: number, startTime?: number, duration?: number) => {
    if (!lifestyleReady && !lifestyleNoticeShown) {
      toast.message('生活時間が未設定のため、学習可能時間は仮の表示になります。', {
        action: {
          label: '設定する',
          onClick: () => onNavigateSettings(),
        },
      });
      setLifestyleNoticeShown(true);
    }
    const now = new Date();
    const nowMinutes = now.getHours() * 60 + now.getMinutes();
    const roundedNow = roundToStep(nowMinutes, 30);
    const resolvedDay = typeof dayOfWeek === 'number' ? dayOfWeek : selectedDay;
    const resolvedStart =
      typeof startTime === 'number'
        ? startTime
        : typeof lastTouchedTime === 'number'
          ? lastTouchedTime
          : roundedNow;
    setEditingItem({
      weekId,
      type: 'study',
      dayOfWeek: resolvedDay,
      startTime: resolvedStart,
      duration: duration ?? 30,
      status: 'planned',
    });
    setItemSheetOpen(true);
  };

  const openLifestyleItemDialog = (item: PlanItem) => {
    setEditingLifestyleItem(item);
    setLifestyleItemOpen(true);
  };

  const handleSaveItem = (item: PlanItem) => {
    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const nextItem = { ...item, weekId: ensured.week.id };
      const exists = prev.planItems.some((i) => i.id === nextItem.id);
      const nextItems = exists
        ? prev.planItems.map((i) => (i.id === nextItem.id ? nextItem : i))
        : [...prev.planItems, nextItem];

      return {
        ...ensured.next,
        planItems: nextItems,
        planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
        lastUsedCategoryId: nextItem.categoryId ?? prev.lastUsedCategoryId,
      };
    });
    toast.success('学習ブロックを保存しました');
  };

  const handleSaveLifestyleItem = () => {
    if (!editingLifestyleItem) return;
    const startTime = timeStringToMinutes(lifestyleStart);
    const endTime = timeStringToMinutes(lifestyleEnd);
    const duration = getLifestyleDurationMinutes(startTime, endTime);
    if (duration <= 0) {
      toast.error('開始と終了を正しく設定してください');
      return;
    }

    const nextItem: PlanItem = {
      ...editingLifestyleItem,
      isAutoGenerated: false,
      startTime,
      duration,
      label:
        editingLifestyleItem.type === 'fixed'
          ? lifestyleLabel.trim() || '固定予定'
          : editingLifestyleItem.label ?? '睡眠',
      categoryId:
        editingLifestyleItem.type === 'fixed'
          ? lifestyleCategoryId === 'none'
            ? undefined
            : lifestyleCategoryId
          : editingLifestyleItem.categoryId,
    };

    handleUpdateItem(nextItem);
    toast.success('予定を更新しました');
    setLifestyleItemOpen(false);
    setEditingLifestyleItem(null);
  };

  const handleUpdateItem = (item: PlanItem) => {
    if (item.type !== 'study') {
      const nextItem = { ...item, isAutoGenerated: false };
      onUpdateData((prev) => {
        const ensured = ensureWeek(prev);
        const baseItems = getWeekLifestyleItemsFromData(prev, ensured.week.id).map((base) => ({
          ...base,
          isAutoGenerated: false,
        }));
        const exists = baseItems.some((base) => base.id === nextItem.id);
        const nextLifestyleItems = exists
          ? baseItems.map((base) => (base.id === nextItem.id ? { ...nextItem, weekId: ensured.week.id } : base))
          : [...baseItems, { ...nextItem, weekId: ensured.week.id }];
        const filtered = prev.planItems.filter(
          (current) => current.weekId !== ensured.week.id || current.type === 'study',
        );
        return {
          ...ensured.next,
          planItems: [...filtered, ...nextLifestyleItems],
          planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
        };
      });
      return;
    }

    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const exists = prev.planItems.some((i) => i.id === item.id);
      const nextItems = exists
        ? prev.planItems.map((i) => (i.id === item.id ? { ...item, weekId: ensured.week.id } : i))
        : [...prev.planItems, { ...item, weekId: ensured.week.id }];
      return {
        ...ensured.next,
        planItems: nextItems,
        planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
      };
    });
  };

  const handleToggleDone = (item: PlanItem) => {
    handleUpdateItem({ ...item, status: item.status === 'done' ? 'planned' : 'done' });
  };

  const deleteItemWithUndo = (item: PlanItem) => {
    onUpdateData((prev) => ({
      ...prev,
      planItems: prev.planItems.filter((existing) => existing.id !== item.id),
    }));
    toast.message('学習ブロックを削除しました', {
      action: {
        label: '元に戻す',
        onClick: () => {
          onUpdateData((prev) => {
            if (prev.planItems.some((existing) => existing.id === item.id)) {
              return prev;
            }
            return {
              ...prev,
              planItems: [...prev.planItems, item],
            };
          });
        },
      },
    });
  };

  const handleDeleteItem = () => {
    if (!editingItem?.id) return;
    const target = weekItems.find((item) => item.id === editingItem.id) ?? (editingItem as PlanItem);
    deleteItemWithUndo(target);
    setEditingItem(null);
  };

  const handleDeleteItemById = (item: PlanItem) => {
    if (item.type !== 'study') {
      onUpdateData((prev) => {
        const ensured = ensureWeek(prev);
        const baseItems = getWeekLifestyleItemsFromData(prev, ensured.week.id).map((base) => ({
          ...base,
          isAutoGenerated: false,
        }));
        const nextLifestyleItems = baseItems.filter((base) => base.id !== item.id);
        const filtered = prev.planItems.filter(
          (current) => current.weekId !== ensured.week.id || current.type === 'study',
        );
        return {
          ...ensured.next,
          planItems: [...filtered, ...nextLifestyleItems],
          planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
        };
      });
      toast.message('この週の生活時間を更新しました');
      return;
    }
    deleteItemWithUndo(item);
  };

  const handleAutoGenerate = (mode: AutoGenerateMode) => {
    if (data.materials.length === 0) {
      toast.message('教材が登録されていません。先に教材を追加してください。');
      onNavigateMaterials();
      return;
    }

    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const newAutoItems = generateAutoItems({ weekStart: period.start, weekId: ensured.week.id, materials: prev.materials });
      const filtered = mode === 'replace'
        ? prev.planItems.filter(
            (item) =>
              item.weekId !== ensured.week.id ||
              item.type !== 'study' ||
              !item.isAutoGenerated,
          )
        : prev.planItems;
      return {
        ...ensured.next,
        planItems: [...filtered, ...newAutoItems],
        planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
      };
    });
    toast.success(mode === 'replace' ? '自動タスクを作り直しました' : '自動タスクを追加しました');
  };

  const normalizeLabel = (value?: string | null) => {
    if (!value) return '';
    const trimmed = value.trim();
    if (!trimmed) return '';
    if (/^[?？]+$/.test(trimmed)) return '';
    return trimmed;
  };


  return (
    <AppChrome
      title="今週の計画"
      actions={null}
    >
      <PageLayout>
        <section className="space-y-4">
          {!lifestyleReady ? (
            <div className="flex flex-wrap items-center justify-between gap-3 rounded-2xl border border-dashed border-border/70 bg-muted/30 px-4 py-3 text-sm text-muted-foreground">
              <div>
                生活時間が未設定です。学習可能時間を計算するために登録してください。
              </div>
              <Button size="sm" onClick={() => setSetupOpen(true)}>
                生活時間を登録
              </Button>
            </div>
          ) : null}
          <WeekSummary
            period={period}
            onChangePeriod={onChangePeriod}
            budgetRemainingDisplay={remainingDisplay}
            budgetTotalDisplay={budgetTotalDisplay}
            budgetPlannedDisplay={budgetPlannedDisplay}
            budgetRemainingRatio={budgetRemainingRatio}
            budgetOver={budgetOver}
            budgetReady={lifestyleReady}
            completionLabel={completionLabel}
            progressValue={progressValue}
            doneTotalDisplay={doneTotalDisplay}
            categorySummary={categorySummary}
            onNavigateSettings={onNavigateSettings}
            showTodayToggle={isDesktop}
            todayPanelOpen={todayPanelOpen}
            onToggleTodayPanel={() => setTodayPanelOpen((value) => !value)}
          />

          <ScheduleView
            displayItems={displayItems}
            studyItems={studyItems}
            categories={data.categories}
            materials={data.materials}
            weekStartDate={period.start}
            lifestyleReady={lifestyleReady}
            selectedDay={selectedDay}
            onSelectDay={setSelectedDay}
            onSelectSlot={(dayOfWeek, startTime, duration) => {
              setSelectedDay(dayOfWeek);
              setLastTouchedTime(startTime);
              openNewItemSheet(dayOfWeek, startTime, duration ?? 30);
            }}
            onEditItem={(item) => {
              setSelectedDay(item.dayOfWeek);
              setEditingItem(item);
              setItemSheetOpen(true);
            }}
            onToggleDone={handleToggleDone}
            onItemChange={handleUpdateItem}
            onItemDelete={handleDeleteItemById}
            onOpenNewItem={() => openNewItemSheet()}
            onNavigateMaterials={onNavigateMaterials}
            onLifestyleEdit={openLifestyleItemDialog}
            weekGoals={weekGoals}
            onGoalChange={handleGoalChange}
            onGoalToggle={handleGoalToggle}
            onGoalAdd={handleGoalAdd}
            onGoalDelete={handleGoalDelete}
            todayPanelOpen={todayPanelOpen}
          />
        </section>
      </PageLayout>

      <BlockSheet
        open={itemSheetOpen}
        onOpenChange={(open) => {
          setItemSheetOpen(open);
          if (!open) setEditingItem(null);
        }}
        categories={data.categories}
        materials={data.materials}
        initial={
          editingItem ?? {
            dayOfWeek: selectedDay,
            startTime: 19 * 60,
            duration: 60,
            status: 'planned',
          }
        }
        defaultCategoryId={data.lastUsedCategoryId ?? data.categories[0]?.id}
        onSave={handleSaveItem}
        onDelete={editingItem?.id ? handleDeleteItem : undefined}
        onCreateCategory={(name) => {
          const trimmed = name.trim();
          if (!trimmed) return null;
          if (data.categories.some((c) => c.name === trimmed)) {
            toast.message('同名のカテゴリがすでにあります。');
            return null;
          }
          const usedColors = data.categories.map((c) => c.color);
          const created = createCategory(trimmed, usedColors);
          onUpdateData((prev) => ({ ...prev, categories: [...prev.categories, created] }));
          toast.success('カテゴリを追加しました');
          return created;
        }}
      />

      <Dialog
        open={lifestyleItemOpen}
        onOpenChange={(open) => {
          setLifestyleItemOpen(open);
          if (!open) setEditingLifestyleItem(null);
        }}
      >
        <DialogContent className="sm:max-w-[520px]">
          <DialogHeader>
            <DialogTitle>生活時間を編集</DialogTitle>
            <DialogDescription>この予定だけを変更します。</DialogDescription>
          </DialogHeader>
          {editingLifestyleItem ? (
            <div className="space-y-4">
              <div className="grid gap-3 sm:grid-cols-2">
                <div className="space-y-1">
                  <Label>曜日</Label>
                  <div className="rounded-lg border border-border bg-muted px-3 py-2 text-sm text-foreground">
                    {DAYS.find((day) => day.value === editingLifestyleItem.dayOfWeek)?.label ?? ''}
                  </div>
                </div>
                <div className="space-y-1">
                  <Label>種別</Label>
                  <div className="rounded-lg border border-border bg-muted px-3 py-2 text-sm text-foreground">
                    {editingLifestyleItem.type === 'fixed' ? '固定予定' : '睡眠'}
                  </div>
                </div>
              </div>

              <div className="grid gap-3 sm:grid-cols-2">
                <div className="space-y-1">
                  <Label htmlFor="lifestyle-start">開始</Label>
                  <Input
                    id="lifestyle-start"
                    type="time"
                    value={lifestyleStart}
                    onChange={(event) => setLifestyleStart(event.target.value)}
                  />
                </div>
                <div className="space-y-1">
                  <Label htmlFor="lifestyle-end">終了</Label>
                  <Input
                    id="lifestyle-end"
                    type="time"
                    value={lifestyleEnd}
                    onChange={(event) => setLifestyleEnd(event.target.value)}
                  />
                </div>
              </div>

              {editingLifestyleItem.type === 'fixed' ? (
                <div className="grid gap-3 sm:grid-cols-2">
                  <div className="space-y-1">
                    <Label htmlFor="lifestyle-label">ラベル</Label>
                    <Input
                      id="lifestyle-label"
                      value={lifestyleLabel}
                      onChange={(event) => setLifestyleLabel(event.target.value)}
                      placeholder="例: 昼休憩"
                    />
                  </div>
                  <div className="space-y-1">
                    <Label>カテゴリ</Label>
                    <Select value={lifestyleCategoryId} onValueChange={setLifestyleCategoryId}>
                      <SelectTrigger>
                        <SelectValue placeholder="カテゴリを選択" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="none">カテゴリなし</SelectItem>
                        {data.categories.map((category) => (
                          <SelectItem key={category.id} value={category.id}>
                            {category.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                </div>
              ) : null}

              <p className="text-xs text-muted-foreground">終了が開始より前の場合は翌日扱いになります。</p>
            </div>
          ) : null}
          <DialogFooter className="gap-2">
            <Button
              variant="outline"
              onClick={() => {
                setLifestyleItemOpen(false);
                setEditingLifestyleItem(null);
              }}
            >
              キャンセル
            </Button>
            <Button onClick={handleSaveLifestyleItem}>保存</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={autoDialogOpen} onOpenChange={setAutoDialogOpen}>
        <DialogContent className="sm:max-w-[420px]">
          <DialogHeader>
            <DialogTitle>自動生成の方法を選択</DialogTitle>
            <DialogDescription>
              既存の自動タスクを置き換えるか、追加で生成するかを選べます。手動で作ったブロックは維持されます。
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-2">
            <label className="flex items-center gap-2 text-sm text-foreground cursor-pointer">
              <input
                type="radio"
                name="autoMode"
                value="append"
                checked={autoMode === 'append'}
                onChange={() => setAutoMode('append')}
              />
              追加する（既存の自動タスクは残す）
            </label>
            <label className="flex items-center gap-2 text-sm text-foreground cursor-pointer">
              <input
                type="radio"
                name="autoMode"
                value="replace"
                checked={autoMode === 'replace'}
                onChange={() => setAutoMode('replace')}
              />
              置き換える（既存の自動タスクを削除して作り直す）
            </label>
          </div>
          <DialogFooter className="gap-2">
            <Button variant="outline" onClick={() => setAutoDialogOpen(false)}>
              キャンセル
            </Button>
            <Button
              onClick={() => {
                handleAutoGenerate(autoMode);
                setAutoDialogOpen(false);
              }}
            >
              実行
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={setupOpen} onOpenChange={setSetupOpen}>
        <DialogContent
          className="sm:max-w-[640px] max-h-[80vh] overflow-y-auto"
          onOpenAutoFocus={(event) => event.preventDefault()}
        >
          <DialogHeader>
            <DialogTitle>{isLifestyleTemplateMissing ? '生活時間を登録' : 'この週の生活時間を編集'}</DialogTitle>
            <DialogDescription>
              {isLifestyleTemplateMissing
                ? '学習可能時間の計算に使われます。'
                : '変更内容はこの週だけに反映されます。'}
            </DialogDescription>
          </DialogHeader>
          <LifestyleForm value={lifestyleDraft} categories={data.categories} onChange={setLifestyleDraft} />
          <DialogFooter className="gap-2">
            <Button variant="outline" onClick={() => setSetupOpen(false)}>
              キャンセル
            </Button>
            <Button
              onClick={() => {
                if (lifestyleDraft.weekdaySleep.startTime === lifestyleDraft.weekdaySleep.endTime) {
                  toast.error('平日の睡眠時間を正しく設定してください');
                  return;
                }
                onUpdateData((prev) => {
                  if (isLifestyleTemplateMissing) {
                    const updatedTemplate = { ...lifestyleDraft, updatedAt: new Date().toISOString() };
                    const filtered = prev.planItems.filter(
                      (item) => item.weekId !== weekId || item.type === 'study',
                    );
                    return {
                      ...prev,
                      lifestyleTemplate: updatedTemplate,
                      planItems: filtered,
                    };
                  }
                  const ensured = ensureWeek(prev);
                  const overrideItems = buildLifestyleItems(ensured.week.id, {
                    ...lifestyleDraft,
                    updatedAt: new Date().toISOString(),
                  }).map((item) => ({ ...item, isAutoGenerated: false }));
                  const filtered = prev.planItems.filter(
                    (item) => item.weekId !== ensured.week.id || item.type === 'study',
                  );
                  return {
                    ...ensured.next,
                    planItems: [...filtered, ...overrideItems],
                    planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
                  };
                });
                toast.success(isLifestyleTemplateMissing ? '生活時間を保存しました' : 'この週の生活時間を保存しました');
                setSetupOpen(false);
              }}
            >
              保存
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </AppChrome>
  );
}
