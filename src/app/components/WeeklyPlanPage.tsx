import React, { useEffect, useMemo, useState } from 'react';
import { differenceInCalendarDays, parseISO } from 'date-fns';
import { Calendar, Clock, PanelRightClose, PanelRightOpen } from 'lucide-react';
import { toast } from 'sonner';

import type { AppData, LifestyleBlock, LifestyleTemplate, PlanItem, PlanWeek, WeeklyGoal } from '../types';
import { createDefaultLifestyleTemplate } from '../data/appDataStore';
import { formatPeriod } from '../utils/date';
import { formatMinutes, minutesToTimeString, timeStringToMinutes } from '../utils/time';
import { PlanItemDialog } from './PlanItemDialog';
import { PlanTimeTable } from './PlanTimeTable';
import { GoalsSection } from './GoalsSection';
import { AppChrome } from './layout/AppChrome';
import { PeriodSelector, type PeriodValue } from './ui/period-selector';
import { Button } from './ui/button';
import { Badge } from './ui/badge';
import { Card, CardContent } from './ui/card';
import { EmptyState } from './ui/empty-state';
import { PageLayout } from './ui/page-layout';
import { Progress } from './ui/progress';
import { Popover, PopoverContent, PopoverTrigger } from './ui/popover';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from './ui/dialog';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { LifestyleForm } from './LifestyleForm';
import { cn } from './ui/utils';

type AutoGenerateMode = 'append' | 'replace';

const DAYS: Array<{ value: number; label: string }> = [
  { value: 0, label: '月' },
  { value: 1, label: '火' },
  { value: 2, label: '水' },
  { value: 3, label: '木' },
  { value: 4, label: '金' },
  { value: 5, label: '土' },
  { value: 6, label: '日' },
];

function createDefaultWeeklyGoals(): WeeklyGoal[] {
  const base = Date.now();
  return Array.from({ length: 3 }).map((_, index) => ({
    id: `goal_${base}_${index}`,
    text: '',
    completed: false,
  }));
}

function weekIdFromStart(start: string) {
  return `week_${start.replace(/-/g, '')}`;
}

function getLifestyleDurationMinutes(startTime: number, endTime: number) {
  if (startTime === endTime) return 0;
  if (endTime < startTime) return endTime + 1440 - startTime;
  return endTime - startTime;
}

function buildLifestyleItems(weekId: string, template: LifestyleTemplate): PlanItem[] {
  const items: PlanItem[] = [];
  for (let day = 0; day < 7; day += 1) {
    const isWeekend = day === 5 || day === 6;
    const sleep = template.weekendEnabled && isWeekend && template.weekendSleep ? template.weekendSleep : template.weekdaySleep;
    const sleepDuration = getLifestyleDurationMinutes(sleep.startTime, sleep.endTime);
    if (sleepDuration > 0) {
      items.push({
        id: `lifestyle_sleep_${weekId}_${day}`,
        weekId,
        type: 'lifestyle',
        dayOfWeek: day,
        startTime: sleep.startTime,
        duration: sleepDuration,
        label: '睡眠',
        status: 'planned',
        isAutoGenerated: true,
      });
    }
  }

  template.optionalBlocks.forEach((block) => {
    const days = Array.isArray(block.daysOfWeek) ? Array.from(new Set(block.daysOfWeek)) : [];
    days.forEach((day) => {
      items.push({
        id: `lifestyle_optional_${weekId}_${block.id}_${day}`,
        weekId,
        type: 'fixed',
        dayOfWeek: day,
        startTime: block.startTime,
        duration: block.duration,
        categoryId: block.categoryId,
        label: block.label,
        status: 'planned',
        isAutoGenerated: true,
      });
    });
  });

  return items;
}

function getWeekLifestyleItemsFromData(data: AppData, weekId: string) {
  const weekItems = data.planItems.filter((item) => item.weekId === weekId);
  const overrides = weekItems.filter((item) => item.type !== 'study');
  if (overrides.length > 0) return overrides;
  const template = data.lifestyleTemplate ?? createDefaultLifestyleTemplate();
  if (template.weekdaySleep.startTime === template.weekdaySleep.endTime) return [];
  return buildLifestyleItems(weekId, template);
}

function hashKey(value: string) {
  let hash = 0;
  for (let i = 0; i < value.length; i += 1) {
    hash = (hash << 5) - hash + value.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash).toString(36);
}

function buildTemplateFromWeekItems(
  weekItems: PlanItem[],
  fallback: LifestyleTemplate,
): LifestyleTemplate {
  const sleepItems = weekItems.filter((item) => item.type === 'lifestyle');
  const weekdaySleepItem =
    sleepItems.find((item) => item.dayOfWeek === 0) ??
    sleepItems.find((item) => item.dayOfWeek >= 0 && item.dayOfWeek <= 4) ??
    null;
  const weekendSleepItem =
    sleepItems.find((item) => item.dayOfWeek === 5) ??
    sleepItems.find((item) => item.dayOfWeek === 6) ??
    null;

  const weekdaySleep = weekdaySleepItem
    ? {
        startTime: weekdaySleepItem.startTime,
        endTime: (weekdaySleepItem.startTime + weekdaySleepItem.duration) % 1440,
      }
    : fallback.weekdaySleep;

  const weekendSleep = weekendSleepItem
    ? {
        startTime: weekendSleepItem.startTime,
        endTime: (weekendSleepItem.startTime + weekendSleepItem.duration) % 1440,
      }
    : fallback.weekendSleep;

  const weekendEnabled =
    Boolean(weekendSleepItem) &&
    (weekdaySleep.startTime !== weekendSleep?.startTime || weekdaySleep.endTime !== weekendSleep?.endTime);

  const fixedItems = weekItems.filter((item) => item.type === 'fixed');
  const blocks = new Map<string, LifestyleBlock>();

  fixedItems.forEach((item) => {
    const label = item.label ?? '固定予定';
    const key = `${label}|${item.startTime}|${item.duration}|${item.categoryId ?? ''}`;
    const id = `block_${hashKey(key)}`;
    const existing = blocks.get(key);
    if (existing) {
      if (!existing.daysOfWeek.includes(item.dayOfWeek)) {
        existing.daysOfWeek.push(item.dayOfWeek);
      }
      return;
    }
    blocks.set(key, {
      id,
      label,
      daysOfWeek: [item.dayOfWeek],
      startTime: item.startTime,
      duration: item.duration,
      categoryId: item.categoryId,
    });
  });

  return {
    ...fallback,
    weekdaySleep,
    weekendEnabled,
    weekendSleep: weekendEnabled ? weekendSleep ?? fallback.weekendSleep : undefined,
    optionalBlocks: Array.from(blocks.values()).sort((a, b) => a.startTime - b.startTime),
    updatedAt: new Date().toISOString(),
  };
}

function computeAvailableMinutes(template: LifestyleTemplate | undefined) {
  if (!template) return 0;
  const totalWeekMinutes = 7 * 24 * 60;
  let lifestyleMinutes = 0;
  for (let day = 0; day < 7; day += 1) {
    const isWeekend = day === 5 || day === 6;
    const sleep = template.weekendEnabled && isWeekend && template.weekendSleep ? template.weekendSleep : template.weekdaySleep;
    lifestyleMinutes += getLifestyleDurationMinutes(sleep.startTime, sleep.endTime);
  }
  lifestyleMinutes += template.optionalBlocks.reduce((sum, block) => {
    const count = Array.isArray(block.daysOfWeek) ? block.daysOfWeek.length : 0;
    return sum + block.duration * count;
  }, 0);
  return Math.max(0, totalWeekMinutes - lifestyleMinutes);
}

function computeAvailableMinutesFromItems(items: PlanItem[]) {
  const totalWeekMinutes = 7 * 24 * 60;
  const lifestyleMinutes = items.reduce((sum, item) => sum + item.duration, 0);
  return Math.max(0, totalWeekMinutes - lifestyleMinutes);
}

function computeCategoryTotals(items: PlanItem[]) {
  const totals = new Map<string, number>();
  items.forEach((item) => {
    if (!item.categoryId) return;
    const minutes = item.actualDuration ?? item.duration;
    totals.set(item.categoryId, (totals.get(item.categoryId) ?? 0) + minutes);
  });
  return totals;
}

function generateAutoItems(params: {
  weekStart: string;
  weekId: string;
  materials: AppData['materials'];
}): PlanItem[] {
  const weekStartDate = parseISO(params.weekStart);
  const slots = [
    { dayOfWeek: 0, startTime: 19 * 60 },
    { dayOfWeek: 2, startTime: 19 * 60 },
    { dayOfWeek: 4, startTime: 19 * 60 },
    { dayOfWeek: 6, startTime: 10 * 60 },
    { dayOfWeek: 1, startTime: 20 * 60 },
    { dayOfWeek: 3, startTime: 20 * 60 },
    { dayOfWeek: 5, startTime: 10 * 60 },
  ];
  let slotIndex = 0;

  return params.materials.flatMap((material) => {
    const deadline = parseISO(material.deadline);
    const daysToDeadline = differenceInCalendarDays(deadline, weekStartDate);
    if (Number.isNaN(daysToDeadline) || daysToDeadline < 0) return [];

    const sessions = daysToDeadline <= 14 ? 2 : 1;
    return Array.from({ length: sessions }).map((_, idx) => {
      const slot = slots[slotIndex % slots.length];
      slotIndex += 1;
      return {
        id: `auto_${params.weekId}_${material.id}_${idx}`,
        weekId: params.weekId,
        type: 'study',
        dayOfWeek: slot.dayOfWeek,
        startTime: slot.startTime,
        duration: 60,
        categoryId: material.categoryId,
        materialId: material.id,
        label: material.name,
        status: 'planned',
        isAutoGenerated: true,
      } satisfies PlanItem;
    });
  });
}

export function WeeklyPlanPage({
  data,
  period,
  onChangePeriod,
  onUpdateData,
  onNavigateSettings,
  onNavigateMaterials,
}: {
  data: AppData;
  period: PeriodValue;
  onChangePeriod: (next: PeriodValue) => void;
  onUpdateData: (updater: (prev: AppData) => AppData) => void;
  onNavigateSettings: () => void;
  onNavigateMaterials: () => void;
}) {
  const weekId = weekIdFromStart(period.start);
  const week = data.planWeeks.find((w) => w.weekStartDate === period.start);
  const weekItems = useMemo(() => data.planItems.filter((item) => item.weekId === weekId), [data.planItems, weekId]);
  const weekLifestyleOverrides = useMemo(
    () => weekItems.filter((item) => item.type !== 'study'),
    [weekItems],
  );
  const hasWeekLifestyleOverride = weekLifestyleOverrides.length > 0;
  const studyItems = weekItems.filter((item) => item.type === 'study');
  const doneItems = studyItems.filter((item) => item.status === 'done');
  const defaultGoals = useMemo(() => createDefaultWeeklyGoals(), [period.start]);
  const weekGoals = week?.goals ?? defaultGoals;

  const baseLifestyleTemplate = useMemo(
    () => data.lifestyleTemplate ?? createDefaultLifestyleTemplate(),
    [data.lifestyleTemplate],
  );
  const weekLifestyleTemplate = useMemo(() => {
    if (hasWeekLifestyleOverride) {
      return buildTemplateFromWeekItems(weekLifestyleOverrides, baseLifestyleTemplate);
    }
    return data.lifestyleTemplate;
  }, [hasWeekLifestyleOverride, weekLifestyleOverrides, baseLifestyleTemplate, data.lifestyleTemplate]);
  const lifestyleReady = Boolean(
    weekLifestyleTemplate &&
      weekLifestyleTemplate.weekdaySleep &&
      weekLifestyleTemplate.weekdaySleep.startTime !== weekLifestyleTemplate.weekdaySleep.endTime,
  );
  const lifestyleItems = weekLifestyleTemplate ? buildLifestyleItems(weekId, weekLifestyleTemplate) : [];
  const displayLifestyleItems = hasWeekLifestyleOverride ? weekLifestyleOverrides : lifestyleItems;
  const displayItems = lifestyleReady ? [...displayLifestyleItems, ...studyItems] : studyItems;

  const availableMinutes = hasWeekLifestyleOverride
    ? computeAvailableMinutesFromItems(displayLifestyleItems)
    : computeAvailableMinutes(weekLifestyleTemplate);
  const doneMinutes = doneItems.reduce((sum, item) => sum + (item.actualDuration ?? item.duration), 0);
  const plannedMinutes = studyItems.reduce((sum, item) => sum + item.duration, 0);
  const remainingAvailableMinutes = availableMinutes - plannedMinutes;
  const completionRate = plannedMinutes > 0 ? Math.round((doneMinutes / plannedMinutes) * 100) : 0;
  const progressValue = plannedMinutes > 0 ? Math.min(100, (doneMinutes / plannedMinutes) * 100) : 0;
  const remainingValue =
    plannedMinutes === 0
      ? '予定を入れると表示'
      : remainingAvailableMinutes >= 0
        ? formatMinutes(remainingAvailableMinutes)
        : `-${formatMinutes(Math.abs(remainingAvailableMinutes))}`;
  const remainingDisplay = lifestyleReady
    ? plannedMinutes === 0
      ? formatMinutes(availableMinutes)
      : remainingValue
    : '未設定';
  const completionLabel = plannedMinutes > 0 ? `${completionRate}%` : '—';
  const doneTotalDisplay = doneMinutes === 0 ? '0分' : formatMinutes(doneMinutes);

  const doneCategoryTotals = computeCategoryTotals(doneItems);
  const plannedCategoryTotals = new Map<string, number>();
  studyItems.forEach((item) => {
    if (!item.categoryId) return;
    plannedCategoryTotals.set(item.categoryId, (plannedCategoryTotals.get(item.categoryId) ?? 0) + item.duration);
  });
  const categorySummary = Array.from(plannedCategoryTotals.entries())
    .map(([categoryId, planned]) => ({
      category: data.categories.find((c) => c.id === categoryId),
      planned,
      done: doneCategoryTotals.get(categoryId) ?? 0,
    }))
    .filter((entry) => entry.category)
    .sort((a, b) => b.planned - a.planned);

  const todayIndex = useMemo(() => {
    const jsDay = new Date().getDay();
    return (jsDay + 6) % 7;
  }, []);
  const todayStudyItems = studyItems.filter((item) => item.dayOfWeek === todayIndex);
  const todaySchedule = [...todayStudyItems].sort((a, b) => a.startTime - b.startTime);
  const todayPlannedMinutes = todayStudyItems.reduce((sum, item) => sum + item.duration, 0);

  const now = new Date();
  const nowMinutes = now.getHours() * 60 + now.getMinutes();
  const nextScheduledItem = todayStudyItems
    .filter((item) => item.status !== 'done' && item.startTime >= nowMinutes)
    .sort((a, b) => a.startTime - b.startTime)[0];

  const [itemDialogOpen, setItemDialogOpen] = useState(false);
  const [editingItem, setEditingItem] = useState<
    (Partial<PlanItem> & Pick<PlanItem, 'dayOfWeek' | 'startTime' | 'duration'>) | null
  >(null);
  const [autoDialogOpen, setAutoDialogOpen] = useState(false);
  const [autoMode, setAutoMode] = useState<AutoGenerateMode>('append');
  const [setupOpen, setSetupOpen] = useState(false);
  const [lifestyleDraft, setLifestyleDraft] = useState<LifestyleTemplate>(baseLifestyleTemplate);
  const [lifestyleItemOpen, setLifestyleItemOpen] = useState(false);
  const [todayPanelOpen, setTodayPanelOpen] = useState(true);
  const [editingLifestyleItem, setEditingLifestyleItem] = useState<PlanItem | null>(null);
  const [lifestyleStart, setLifestyleStart] = useState('00:00');
  const [lifestyleEnd, setLifestyleEnd] = useState('00:00');
  const [lifestyleLabel, setLifestyleLabel] = useState('');
  const [lifestyleCategoryId, setLifestyleCategoryId] = useState('none');

  useEffect(() => {
    if (!setupOpen) return;
    if (weekLifestyleTemplate) {
      setLifestyleDraft(weekLifestyleTemplate);
      return;
    }
    setLifestyleDraft(baseLifestyleTemplate);
  }, [setupOpen, weekLifestyleTemplate, baseLifestyleTemplate]);

  useEffect(() => {
    if (!editingLifestyleItem) return;
    setLifestyleStart(minutesToTimeString(editingLifestyleItem.startTime));
    setLifestyleEnd(minutesToTimeString((editingLifestyleItem.startTime + editingLifestyleItem.duration) % 1440));
    setLifestyleLabel(
      editingLifestyleItem.type === 'fixed'
        ? editingLifestyleItem.label ?? '固定予定'
        : editingLifestyleItem.label ?? '睡眠',
    );
    setLifestyleCategoryId(editingLifestyleItem.categoryId ?? 'none');
  }, [editingLifestyleItem]);

  useEffect(() => {
    if (typeof window === 'undefined') return;
    if (window.innerWidth < 1024) {
      setTodayPanelOpen(false);
    }
  }, []);

  const ensureWeek = (
    prev: AppData,
    target?: { start: string; end: string },
  ): { next: AppData; week: PlanWeek } => {
    const start = target?.start ?? period.start;
    const end = target?.end ?? period.end;
    const targetId = weekIdFromStart(start);
    const existing = prev.planWeeks.find((w) => w.weekStartDate === start);
    if (existing) return { next: prev, week: existing };
    const now = new Date().toISOString();
    const nextWeek: PlanWeek = {
      id: targetId,
      weekStartDate: start,
      weekEndDate: end,
      createdAt: now,
      updatedAt: now,
      goals: defaultGoals,
    };
    return { next: { ...prev, planWeeks: [nextWeek, ...prev.planWeeks] }, week: nextWeek };
  };

  const touchWeek = (weeks: PlanWeek[], targetId: string) => {
    const now = new Date().toISOString();
    return weeks.map((w) => (w.id === targetId ? { ...w, updatedAt: now } : w));
  };

  const updateWeekGoals = (updater: (prevGoals: WeeklyGoal[]) => WeeklyGoal[]) => {
    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const currentGoals = ensured.week.goals ?? defaultGoals;
      const nextGoals = updater(currentGoals);
      const now = new Date().toISOString();
      return {
        ...ensured.next,
        planWeeks: ensured.next.planWeeks.map((w) =>
          w.id === ensured.week.id ? { ...w, goals: nextGoals, updatedAt: now } : w,
        ),
      };
    });
  };

  const handleGoalChange = (goalId: string, text: string) => {
    updateWeekGoals((prevGoals) => prevGoals.map((goal) => (goal.id === goalId ? { ...goal, text } : goal)));
  };

  const handleGoalToggle = (goalId: string) => {
    updateWeekGoals((prevGoals) =>
      prevGoals.map((goal) => (goal.id === goalId ? { ...goal, completed: !goal.completed } : goal)),
    );
  };

  const handleGoalAdd = () => {
    updateWeekGoals((prevGoals) => [
      ...prevGoals,
      {
        id: `goal_${Date.now()}`,
        text: '',
        completed: false,
      },
    ]);
  };

  const handleGoalDelete = (goalId: string) => {
    updateWeekGoals((prevGoals) => prevGoals.filter((goal) => goal.id !== goalId));
  };

  const openNewItemDialog = () => {
    if (!lifestyleReady) {
      setSetupOpen(true);
      return;
    }
    setEditingItem(null);
    setItemDialogOpen(true);
  };

  const openLifestyleItemDialog = (item: PlanItem) => {
    setEditingLifestyleItem(item);
    setLifestyleItemOpen(true);
  };

  const handleSaveItem = (item: PlanItem) => {
    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const nextItem = { ...item, weekId: ensured.week.id };
      const exists = prev.planItems.some((i) => i.id === nextItem.id);
      const nextItems = exists
        ? prev.planItems.map((i) => (i.id === nextItem.id ? nextItem : i))
        : [...prev.planItems, nextItem];

      return {
        ...ensured.next,
        planItems: nextItems,
        planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
        lastUsedCategoryId: nextItem.categoryId ?? prev.lastUsedCategoryId,
      };
    });
    toast.success('学習ブロックを保存しました');
  };

  const handleSaveLifestyleItem = () => {
    if (!editingLifestyleItem) return;
    const startTime = timeStringToMinutes(lifestyleStart);
    const endTime = timeStringToMinutes(lifestyleEnd);
    const duration = getLifestyleDurationMinutes(startTime, endTime);
    if (duration <= 0) {
      toast.error('開始と終了を正しく設定してください');
      return;
    }

    const nextItem: PlanItem = {
      ...editingLifestyleItem,
      startTime,
      duration,
      label:
        editingLifestyleItem.type === 'fixed'
          ? lifestyleLabel.trim() || '固定予定'
          : editingLifestyleItem.label ?? '睡眠',
      categoryId:
        editingLifestyleItem.type === 'fixed'
          ? lifestyleCategoryId === 'none'
            ? undefined
            : lifestyleCategoryId
          : editingLifestyleItem.categoryId,
    };

    handleUpdateItem(nextItem);
    toast.success('予定を更新しました');
    setLifestyleItemOpen(false);
    setEditingLifestyleItem(null);
  };

  const handleUpdateItem = (item: PlanItem) => {
    if (item.type !== 'study') {
      onUpdateData((prev) => {
        const ensured = ensureWeek(prev);
        const baseItems = getWeekLifestyleItemsFromData(prev, ensured.week.id);
        const exists = baseItems.some((base) => base.id === item.id);
        const nextLifestyleItems = exists
          ? baseItems.map((base) => (base.id === item.id ? { ...item, weekId: ensured.week.id } : base))
          : [...baseItems, { ...item, weekId: ensured.week.id }];
        const filtered = prev.planItems.filter(
          (current) => current.weekId !== ensured.week.id || current.type === 'study',
        );
        return {
          ...ensured.next,
          planItems: [...filtered, ...nextLifestyleItems],
          planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
        };
      });
      return;
    }

    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const exists = prev.planItems.some((i) => i.id === item.id);
      const nextItems = exists
        ? prev.planItems.map((i) => (i.id === item.id ? { ...item, weekId: ensured.week.id } : i))
        : [...prev.planItems, { ...item, weekId: ensured.week.id }];
      return {
        ...ensured.next,
        planItems: nextItems,
        planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
      };
    });
  };

  const handleMarkDone = (item: PlanItem) => {
    handleUpdateItem({ ...item, status: 'done' });
  };

  const deleteItemWithUndo = (item: PlanItem) => {
    onUpdateData((prev) => ({
      ...prev,
      planItems: prev.planItems.filter((existing) => existing.id !== item.id),
    }));
    toast.message('学習ブロックを削除しました', {
      action: {
        label: '元に戻す',
        onClick: () => {
          onUpdateData((prev) => {
            if (prev.planItems.some((existing) => existing.id === item.id)) {
              return prev;
            }
            return {
              ...prev,
              planItems: [...prev.planItems, item],
            };
          });
        },
      },
    });
  };

  const handleDeleteItem = () => {
    if (!editingItem?.id) return;
    const target = weekItems.find((item) => item.id === editingItem.id) ?? (editingItem as PlanItem);
    deleteItemWithUndo(target);
    setEditingItem(null);
  };

  const handleDeleteItemById = (item: PlanItem) => {
    if (item.type !== 'study') {
      onUpdateData((prev) => {
        const ensured = ensureWeek(prev);
        const baseItems = getWeekLifestyleItemsFromData(prev, ensured.week.id);
        const nextLifestyleItems = baseItems.filter((base) => base.id !== item.id);
        const filtered = prev.planItems.filter(
          (current) => current.weekId !== ensured.week.id || current.type === 'study',
        );
        return {
          ...ensured.next,
          planItems: [...filtered, ...nextLifestyleItems],
          planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
        };
      });
      toast.message('この週の生活時間を更新しました');
      return;
    }
    deleteItemWithUndo(item);
  };

  const handleAutoGenerate = (mode: AutoGenerateMode) => {
    if (data.materials.length === 0) {
      toast.message('教材が登録されていません。先に教材を追加してください。');
      onNavigateMaterials();
      return;
    }

    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const newAutoItems = generateAutoItems({ weekStart: period.start, weekId: ensured.week.id, materials: prev.materials });
      const filtered = mode === 'replace'
        ? prev.planItems.filter(
            (item) =>
              item.weekId !== ensured.week.id ||
              item.type !== 'study' ||
              !item.isAutoGenerated,
          )
        : prev.planItems;
      return {
        ...ensured.next,
        planItems: [...filtered, ...newAutoItems],
        planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
      };
    });
    toast.success(mode === 'replace' ? '自動タスクを作り直しました' : '自動タスクを追加しました');
  };

  const normalizeLabel = (value?: string | null) => {
    if (!value) return '';
    const trimmed = value.trim();
    if (!trimmed) return '';
    if (/^[?？]+$/.test(trimmed)) return '';
    return trimmed;
  };

  const weekSlotCount = studyItems.length;
  const todaySlotCount = todayStudyItems.length;
  const nextLabel = nextScheduledItem
    ? `今日 ${minutesToTimeString(nextScheduledItem.startTime)}〜${minutesToTimeString(
        nextScheduledItem.startTime + nextScheduledItem.duration,
      )}（${formatMinutes(nextScheduledItem.duration)}）`
    : '';

  return (
    <AppChrome
      title="今週の計画"
      actions={null}
    >
      <PageLayout>
        <section className="space-y-4">
          <Card>
            <CardContent className="py-3">
              <div className="flex flex-col gap-4 lg:flex-row lg:items-center lg:justify-between">
                <div className="flex items-center gap-2 text-xs text-muted-foreground">
                  <Calendar className="w-4 h-4 text-muted-foreground/70" />
                  <PeriodSelector value={period} onChange={onChangePeriod} mode="week" weekStartsOn={1} />
                  <span>{formatPeriod(period.start, period.end)}</span>
                </div>

                <div className="flex flex-1 flex-wrap items-center justify-center gap-8 text-xs text-muted-foreground">
                  <div className="flex flex-col gap-1">
                    <span className="text-[11px]">残り時間</span>
                    <span className="text-sm font-semibold text-foreground">{remainingDisplay}</span>
                  </div>
                  <div className="flex flex-col gap-1">
                    <span className="text-[11px]">進捗</span>
                    <div className="flex items-center gap-2">
                      <Progress value={progressValue} className="h-1.5 w-[150px] bg-secondary" />
                      <span className="text-sm font-semibold text-foreground">{completionLabel}</span>
                    </div>
                  </div>
                  <div className="flex flex-col gap-1">
                    <span className="text-[11px]">実績合計</span>
                    <span className="text-sm font-semibold text-foreground">{doneTotalDisplay}</span>
                  </div>
                </div>

                <div className="flex items-center gap-2">
                  <Popover>
                    <PopoverTrigger asChild>
                      <Button variant="ghost" size="sm">
                        詳細
                      </Button>
                    </PopoverTrigger>
                    <PopoverContent align="end" className="w-64">
                      <div className="space-y-3">
                        <div className="text-sm font-semibold text-foreground">実績（内訳）</div>
                        {categorySummary.length === 0 ? (
                          <div className="text-xs text-muted-foreground">まだ記録はありません。</div>
                        ) : (
                          <div className="space-y-3">
                            {categorySummary.slice(0, 5).map((entry) => {
                              const ratio = entry.planned > 0 ? Math.min(1, entry.done / entry.planned) : 0;
                              const fillClass =
                                entry.category?.color
                                  ?.split(' ')
                                  .find((item) => item.startsWith('bg-')) ?? 'bg-secondary';
                              const categoryName = normalizeLabel(entry.category?.name) ?? '未分類';
                              return (
                                <div key={entry.category?.id ?? categoryName} className="space-y-1">
                                  <div className="flex items-center justify-between text-xs">
                                    <div className="flex items-center gap-2">
                                      <Badge variant="outline" className={entry.category?.color ?? ''}>
                                        {categoryName}
                                      </Badge>
                                      <span className="text-muted-foreground">実績 {formatMinutes(entry.done)}</span>
                                    </div>
                                    <span className="font-semibold font-mono text-foreground">{formatMinutes(entry.planned)}</span>
                                  </div>
                                  <div className="h-1.5 rounded-full bg-secondary overflow-hidden">
                                    <div
                                      className={cn('h-full rounded-full transition-all duration-300', fillClass)}
                                      style={{ width: `${ratio * 100}%` }}
                                    />
                                  </div>
                                </div>
                              );
                            })}
                          </div>
                        )}
                      </div>
                    </PopoverContent>
                  </Popover>
                  <Button variant="outline" size="sm" onClick={onNavigateSettings}>
                    生活時間を編集
                  </Button>
                  <Button
                    variant="ghost"
                    size="icon"
                    onClick={() => setTodayPanelOpen((value) => !value)}
                    aria-label={todayPanelOpen ? '今日の予定を閉じる' : '今日の予定を開く'}
                  >
                    {todayPanelOpen ? <PanelRightClose className="h-4 w-4" /> : <PanelRightOpen className="h-4 w-4" />}
                  </Button>
                </div>
              </div>
            </CardContent>
          </Card>

          <div className="space-y-1">
            <h2 className="text-base font-semibold text-foreground">今週の計画</h2>
            <div className="flex flex-wrap items-center gap-2 text-xs text-muted-foreground">
              <span>空き枠クリックで30分、ドラッグで範囲追加。予定はドラッグで移動・伸縮できます</span>
            </div>
          </div>

          <div className="flex flex-col gap-4 lg:flex-row lg:items-start">
            <div id="weekly-timetable" className="min-w-0 flex-1 space-y-3">
              <PlanTimeTable
                items={displayItems}
                categories={data.categories}
                materials={data.materials}
                weekStartDate={period.start}
                editable={lifestyleReady}
                allowLifestyleEdit
                className="h-[calc(100vh-260px)] overflow-auto"
                onLifestyleEdit={openLifestyleItemDialog}
                onItemChange={handleUpdateItem}
                onItemDelete={handleDeleteItemById}
                onItemClick={(item) => {
                  setEditingItem(item);
                  setItemDialogOpen(true);
                }}
                onEmptySlotClick={(dayOfWeek, startTime) => {
                  if (!lifestyleReady) {
                    setSetupOpen(true);
                    return;
                  }
                  setEditingItem({
                    weekId,
                    type: 'study',
                    dayOfWeek,
                    startTime,
                    duration: 30,
                    status: 'planned',
                  });
                  setItemDialogOpen(true);
                }}
                onRangeSelect={(dayOfWeek, startTime, duration) => {
                  if (!lifestyleReady) {
                    setSetupOpen(true);
                    return;
                  }
                  setEditingItem({
                    weekId,
                    type: 'study',
                    dayOfWeek,
                    startTime,
                    duration,
                    status: 'planned',
                  });
                  setItemDialogOpen(true);
                }}
              />
              {studyItems.length === 0 ? (
                <EmptyState
                  icon={<Calendar className="w-5 h-5" />}
                  title="今週の予定がまだありません"
                  description="まずは学習ブロックを追加して、今週の流れを作りましょう。"
                  actions={[
                    { label: '学習ブロックを追加', onClick: openNewItemDialog },
                    { label: '教材から割り当て', onClick: onNavigateMaterials, variant: 'outline' },
                  ]}
                />
              ) : null}
            </div>

            <aside
              className={cn(
                'flex-shrink-0 overflow-hidden transition-all duration-300 ease-in-out',
                todayPanelOpen
                  ? 'w-full lg:w-[340px] opacity-100'
                  : 'w-0 opacity-0 pointer-events-none max-lg:hidden',
              )}
              aria-hidden={!todayPanelOpen}
            >
              <div className="h-[calc(100vh-260px)] space-y-4">
                <div id="weekly-goals">
                  <GoalsSection
                    goals={weekGoals}
                    editable
                    onGoalChange={handleGoalChange}
                    onGoalToggle={handleGoalToggle}
                    onGoalAdd={handleGoalAdd}
                    onGoalDelete={handleGoalDelete}
                  />
                </div>
                <div className="flex h-full flex-col overflow-hidden rounded-2xl border border-border/40 bg-foreground text-background">
                  <div className="sticky top-0 z-10 border-b border-border/30 bg-foreground px-4 py-3">
                    <div className="flex items-center justify-between">
                      <div>
                        <p className="text-xs text-background/60">今日の予定</p>
                        <p className="text-sm font-semibold text-background">計画を縦並びで確認できます</p>
                      </div>
                      <div className="text-xs text-background/60">
                        {todaySlotCount}コマ / {formatMinutes(todayPlannedMinutes)}
                      </div>
                    </div>
                  </div>
                  <div className="flex-1 space-y-3 overflow-y-auto px-4 py-3">
                    {todaySchedule.length === 0 ? (
                      <div className="rounded-lg border border-dashed border-border/40 bg-background/5 px-3 py-2 text-xs text-background/70">
                        今日はまだ予定がありません。タイムテーブルから追加できます。
                      </div>
                    ) : (
                      todaySchedule.map((item) => {
                        const startLabel = minutesToTimeString(item.startTime);
                        const endLabel = minutesToTimeString(item.startTime + item.duration);
                        const category = normalizeLabel(data.categories.find((c) => c.id === item.categoryId)?.name) || '学習';
                        const material = normalizeLabel(data.materials.find((m) => m.id === item.materialId)?.name);
                        const title = normalizeLabel(item.label) || material || category;
                        const isCurrent =
                          item.status !== 'done' &&
                          nowMinutes >= item.startTime &&
                          nowMinutes < item.startTime + item.duration;
                        const isDone = item.status === 'done';
                        const cardStyle = isCurrent
                          ? 'border-primary/60 bg-primary/20 text-background shadow-sm'
                          : isDone
                            ? 'border-border/30 bg-background/5 text-background/60'
                            : 'border-border/30 bg-background/10 text-background/80';

                        return (
                          <div key={item.id} className={cn('rounded-lg border px-3 py-2 transition', cardStyle)}>
                            <div className="flex items-center justify-between text-[11px] text-background/60">
                              <div className="flex items-center gap-1.5">
                                <Clock className="h-3.5 w-3.5" />
                                <span className="font-mono">
                                  {startLabel}-{endLabel}
                                </span>
                              </div>
                              <span>{formatMinutes(item.duration)}</span>
                            </div>
                            <div className="mt-1 flex items-center justify-between gap-2">
                              <div className="min-w-0">
                                <div className="truncate text-sm font-medium">{title}</div>
                                <div className="text-[10px] text-background/50">{category}</div>
                              </div>
                              {isDone ? (
                                <span className="text-[10px] text-emerald-300">完了</span>
                              ) : (
                                <button
                                  type="button"
                                  className="rounded-full border border-border/30 px-2.5 py-0.5 text-[10px] text-background/70 hover:bg-background/10"
                                  onClick={() => handleMarkDone(item)}
                                >
                                  完了にする
                                </button>
                              )}
                            </div>
                          </div>
                        );
                      })
                    )}
                  </div>
                </div>
              </div>
            </aside>
          </div>
        </section>
      </PageLayout>

      <PlanItemDialog
        open={itemDialogOpen}
        onOpenChange={(open) => {
          setItemDialogOpen(open);
          if (!open) setEditingItem(null);
        }}
        categories={data.categories}
        materials={data.materials}
        initial={
          editingItem ?? {
            dayOfWeek: 0,
            startTime: 19 * 60,
            duration: 60,
            status: 'planned',
          }
        }
        defaultCategoryId={data.lastUsedCategoryId ?? data.categories[0]?.id}
        onSave={handleSaveItem}
        onDelete={editingItem?.id ? handleDeleteItem : undefined}
      />

      <Dialog
        open={lifestyleItemOpen}
        onOpenChange={(open) => {
          setLifestyleItemOpen(open);
          if (!open) setEditingLifestyleItem(null);
        }}
      >
        <DialogContent className="sm:max-w-[520px]">
          <DialogHeader>
            <DialogTitle>生活時間を編集</DialogTitle>
            <DialogDescription>この予定だけを変更します。</DialogDescription>
          </DialogHeader>
          {editingLifestyleItem ? (
            <div className="space-y-4">
              <div className="grid gap-3 sm:grid-cols-2">
                <div className="space-y-1">
                  <Label>曜日</Label>
                  <div className="rounded-lg border border-border bg-muted px-3 py-2 text-sm text-foreground">
                    {DAYS.find((day) => day.value === editingLifestyleItem.dayOfWeek)?.label ?? ''}
                  </div>
                </div>
                <div className="space-y-1">
                  <Label>種別</Label>
                  <div className="rounded-lg border border-border bg-muted px-3 py-2 text-sm text-foreground">
                    {editingLifestyleItem.type === 'fixed' ? '固定予定' : '睡眠'}
                  </div>
                </div>
              </div>

              <div className="grid gap-3 sm:grid-cols-2">
                <div className="space-y-1">
                  <Label htmlFor="lifestyle-start">開始</Label>
                  <Input
                    id="lifestyle-start"
                    type="time"
                    value={lifestyleStart}
                    onChange={(event) => setLifestyleStart(event.target.value)}
                  />
                </div>
                <div className="space-y-1">
                  <Label htmlFor="lifestyle-end">終了</Label>
                  <Input
                    id="lifestyle-end"
                    type="time"
                    value={lifestyleEnd}
                    onChange={(event) => setLifestyleEnd(event.target.value)}
                  />
                </div>
              </div>

              {editingLifestyleItem.type === 'fixed' ? (
                <div className="grid gap-3 sm:grid-cols-2">
                  <div className="space-y-1">
                    <Label htmlFor="lifestyle-label">ラベル</Label>
                    <Input
                      id="lifestyle-label"
                      value={lifestyleLabel}
                      onChange={(event) => setLifestyleLabel(event.target.value)}
                      placeholder="例: 昼休憩"
                    />
                  </div>
                  <div className="space-y-1">
                    <Label>カテゴリ</Label>
                    <Select value={lifestyleCategoryId} onValueChange={setLifestyleCategoryId}>
                      <SelectTrigger>
                        <SelectValue placeholder="カテゴリを選択" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="none">カテゴリなし</SelectItem>
                        {data.categories.map((category) => (
                          <SelectItem key={category.id} value={category.id}>
                            {category.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                </div>
              ) : null}

              <p className="text-xs text-muted-foreground">終了が開始より前の場合は翌日扱いになります。</p>
            </div>
          ) : null}
          <DialogFooter className="gap-2">
            <Button
              variant="outline"
              onClick={() => {
                setLifestyleItemOpen(false);
                setEditingLifestyleItem(null);
              }}
            >
              キャンセル
            </Button>
            <Button onClick={handleSaveLifestyleItem}>保存</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={autoDialogOpen} onOpenChange={setAutoDialogOpen}>
        <DialogContent className="sm:max-w-[420px]">
          <DialogHeader>
            <DialogTitle>自動生成の方法を選択</DialogTitle>
            <DialogDescription>
              既存の自動タスクを置き換えるか、追加で生成するかを選べます。手動で作ったブロックは維持されます。
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-2">
            <label className="flex items-center gap-2 text-sm text-foreground cursor-pointer">
              <input
                type="radio"
                name="autoMode"
                value="append"
                checked={autoMode === 'append'}
                onChange={() => setAutoMode('append')}
              />
              追加する（既存の自動タスクは残す）
            </label>
            <label className="flex items-center gap-2 text-sm text-foreground cursor-pointer">
              <input
                type="radio"
                name="autoMode"
                value="replace"
                checked={autoMode === 'replace'}
                onChange={() => setAutoMode('replace')}
              />
              置き換える（既存の自動タスクを削除して作り直す）
            </label>
          </div>
          <DialogFooter className="gap-2">
            <Button variant="outline" onClick={() => setAutoDialogOpen(false)}>
              キャンセル
            </Button>
            <Button
              onClick={() => {
                handleAutoGenerate(autoMode);
                setAutoDialogOpen(false);
              }}
            >
              実行
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={setupOpen} onOpenChange={setSetupOpen}>
        <DialogContent className="sm:max-w-[640px]">
          <DialogHeader>
            <DialogTitle>この週の生活時間を編集</DialogTitle>
            <DialogDescription>
              変更内容はこの週だけに反映されます。
            </DialogDescription>
          </DialogHeader>
          <LifestyleForm value={lifestyleDraft} categories={data.categories} onChange={setLifestyleDraft} />
          <DialogFooter className="gap-2">
            <Button variant="outline" onClick={() => setSetupOpen(false)}>
              キャンセル
            </Button>
            <Button
              onClick={() => {
                if (lifestyleDraft.weekdaySleep.startTime === lifestyleDraft.weekdaySleep.endTime) {
                  toast.error('平日の睡眠時間を正しく設定してください');
                  return;
                }
                onUpdateData((prev) => {
                  const ensured = ensureWeek(prev);
                  const overrideItems = buildLifestyleItems(ensured.week.id, {
                    ...lifestyleDraft,
                    updatedAt: new Date().toISOString(),
                  });
                  const filtered = prev.planItems.filter(
                    (item) => item.weekId !== ensured.week.id || item.type === 'study',
                  );
                  return {
                    ...ensured.next,
                    planItems: [...filtered, ...overrideItems],
                    planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
                  };
                });
                toast.success('この週の生活時間を保存しました');
                setSetupOpen(false);
              }}
            >
              保存
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </AppChrome>
  );
}
