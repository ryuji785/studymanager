import React, { useEffect, useMemo, useState } from 'react';
import { differenceInCalendarDays, parseISO } from 'date-fns';
import { Calendar, RefreshCcw } from 'lucide-react';
import { toast } from 'sonner';

import type { AppData, LifestyleBlock, LifestyleTemplate, PlanItem, PlanWeek, WeeklyGoal } from '../types';
import { createDefaultLifestyleTemplate } from '../data/appDataStore';
import { formatPeriod } from '../utils/date';
import { formatMinutes, minutesToTimeString, timeStringToMinutes } from '../utils/time';
import { PlanItemDialog } from './PlanItemDialog';
import { PlanTimeTable } from './PlanTimeTable';
import { GoalsSection } from './GoalsSection';
import { ScheduleStrip } from './ScheduleStrip';
import { AppChrome } from './layout/AppChrome';
import { PeriodSelector, type PeriodValue } from './ui/period-selector';
import { Button } from './ui/button';
import { Badge } from './ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { EmptyState } from './ui/empty-state';
import { PageHeader } from './ui/page-header';
import { PageLayout } from './ui/page-layout';
import { Dialog, DialogContent, DialogDescription, DialogFooter, DialogHeader, DialogTitle } from './ui/dialog';
import { Input } from './ui/input';
import { Label } from './ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from './ui/select';
import { LifestyleForm } from './LifestyleForm';
import { cn } from './ui/utils';

type AutoGenerateMode = 'append' | 'replace';

const DAYS: Array<{ value: number; label: string }> = [
  { value: 0, label: '?' },
  { value: 1, label: '?' },
  { value: 2, label: '?' },
  { value: 3, label: '?' },
  { value: 4, label: '?' },
  { value: 5, label: '?' },
  { value: 6, label: '?' },
];

function createDefaultWeeklyGoals(): WeeklyGoal[] {
  const base = Date.now();
  return Array.from({ length: 3 }).map((_, index) => ({
    id: `goal_${base}_${index}`,
    text: '',
    completed: false,
  }));
}

function weekIdFromStart(start: string) {
  return `week_${start.replace(/-/g, '')}`;
}

function getLifestyleDurationMinutes(startTime: number, endTime: number) {
  if (startTime === endTime) return 0;
  if (endTime < startTime) return endTime + 1440 - startTime;
  return endTime - startTime;
}

function buildLifestyleItems(weekId: string, template: LifestyleTemplate): PlanItem[] {
  const items: PlanItem[] = [];
  for (let day = 0; day < 7; day += 1) {
    const isWeekend = day === 5 || day === 6;
    const sleep = template.weekendEnabled && isWeekend && template.weekendSleep ? template.weekendSleep : template.weekdaySleep;
    const sleepDuration = getLifestyleDurationMinutes(sleep.startTime, sleep.endTime);
    if (sleepDuration > 0) {
      items.push({
        id: `lifestyle_sleep_${weekId}_${day}`,
        weekId,
        type: 'lifestyle',
        dayOfWeek: day,
        startTime: sleep.startTime,
        duration: sleepDuration,
        label: '睡眠',
        status: 'planned',
        isAutoGenerated: true,
      });
    }
  }

  template.optionalBlocks.forEach((block) => {
    const days = Array.isArray(block.daysOfWeek) ? Array.from(new Set(block.daysOfWeek)) : [];
    days.forEach((day) => {
      items.push({
        id: `lifestyle_optional_${weekId}_${block.id}_${day}`,
        weekId,
        type: 'fixed',
        dayOfWeek: day,
        startTime: block.startTime,
        duration: block.duration,
        categoryId: block.categoryId,
        label: block.label,
        status: 'planned',
        isAutoGenerated: true,
      });
    });
  });

  return items;
}

function getWeekLifestyleItemsFromData(data: AppData, weekId: string) {
  const weekItems = data.planItems.filter((item) => item.weekId === weekId);
  const overrides = weekItems.filter((item) => item.type !== 'study');
  if (overrides.length > 0) return overrides;
  const template = data.lifestyleTemplate ?? createDefaultLifestyleTemplate();
  if (template.weekdaySleep.startTime === template.weekdaySleep.endTime) return [];
  return buildLifestyleItems(weekId, template);
}

function hashKey(value: string) {
  let hash = 0;
  for (let i = 0; i < value.length; i += 1) {
    hash = (hash << 5) - hash + value.charCodeAt(i);
    hash |= 0;
  }
  return Math.abs(hash).toString(36);
}

function buildTemplateFromWeekItems(
  weekItems: PlanItem[],
  fallback: LifestyleTemplate,
): LifestyleTemplate {
  const sleepItems = weekItems.filter((item) => item.type === 'lifestyle');
  const weekdaySleepItem =
    sleepItems.find((item) => item.dayOfWeek === 0) ??
    sleepItems.find((item) => item.dayOfWeek >= 0 && item.dayOfWeek <= 4) ??
    null;
  const weekendSleepItem =
    sleepItems.find((item) => item.dayOfWeek === 5) ??
    sleepItems.find((item) => item.dayOfWeek === 6) ??
    null;

  const weekdaySleep = weekdaySleepItem
    ? {
        startTime: weekdaySleepItem.startTime,
        endTime: (weekdaySleepItem.startTime + weekdaySleepItem.duration) % 1440,
      }
    : fallback.weekdaySleep;

  const weekendSleep = weekendSleepItem
    ? {
        startTime: weekendSleepItem.startTime,
        endTime: (weekendSleepItem.startTime + weekendSleepItem.duration) % 1440,
      }
    : fallback.weekendSleep;

  const weekendEnabled =
    Boolean(weekendSleepItem) &&
    (weekdaySleep.startTime !== weekendSleep?.startTime || weekdaySleep.endTime !== weekendSleep?.endTime);

  const fixedItems = weekItems.filter((item) => item.type === 'fixed');
  const blocks = new Map<string, LifestyleBlock>();

  fixedItems.forEach((item) => {
    const label = item.label ?? '固定予定';
    const key = `${label}|${item.startTime}|${item.duration}|${item.categoryId ?? ''}`;
    const id = `block_${hashKey(key)}`;
    const existing = blocks.get(key);
    if (existing) {
      if (!existing.daysOfWeek.includes(item.dayOfWeek)) {
        existing.daysOfWeek.push(item.dayOfWeek);
      }
      return;
    }
    blocks.set(key, {
      id,
      label,
      daysOfWeek: [item.dayOfWeek],
      startTime: item.startTime,
      duration: item.duration,
      categoryId: item.categoryId,
    });
  });

  return {
    ...fallback,
    weekdaySleep,
    weekendEnabled,
    weekendSleep: weekendEnabled ? weekendSleep ?? fallback.weekendSleep : undefined,
    optionalBlocks: Array.from(blocks.values()).sort((a, b) => a.startTime - b.startTime),
    updatedAt: new Date().toISOString(),
  };
}

function computeAvailableMinutes(template: LifestyleTemplate | undefined) {
  if (!template) return 0;
  const totalWeekMinutes = 7 * 24 * 60;
  let lifestyleMinutes = 0;
  for (let day = 0; day < 7; day += 1) {
    const isWeekend = day === 5 || day === 6;
    const sleep = template.weekendEnabled && isWeekend && template.weekendSleep ? template.weekendSleep : template.weekdaySleep;
    lifestyleMinutes += getLifestyleDurationMinutes(sleep.startTime, sleep.endTime);
  }
  lifestyleMinutes += template.optionalBlocks.reduce((sum, block) => {
    const count = Array.isArray(block.daysOfWeek) ? block.daysOfWeek.length : 0;
    return sum + block.duration * count;
  }, 0);
  return Math.max(0, totalWeekMinutes - lifestyleMinutes);
}

function computeAvailableMinutesFromItems(items: PlanItem[]) {
  const totalWeekMinutes = 7 * 24 * 60;
  const lifestyleMinutes = items.reduce((sum, item) => sum + item.duration, 0);
  return Math.max(0, totalWeekMinutes - lifestyleMinutes);
}

function computeCategoryTotals(items: PlanItem[]) {
  const totals = new Map<string, number>();
  items.forEach((item) => {
    if (!item.categoryId) return;
    const minutes = item.actualDuration ?? item.duration;
    totals.set(item.categoryId, (totals.get(item.categoryId) ?? 0) + minutes);
  });
  return totals;
}

function generateAutoItems(params: {
  weekStart: string;
  weekId: string;
  materials: AppData['materials'];
}): PlanItem[] {
  const weekStartDate = parseISO(params.weekStart);
  const slots = [
    { dayOfWeek: 0, startTime: 19 * 60 },
    { dayOfWeek: 2, startTime: 19 * 60 },
    { dayOfWeek: 4, startTime: 19 * 60 },
    { dayOfWeek: 6, startTime: 10 * 60 },
    { dayOfWeek: 1, startTime: 20 * 60 },
    { dayOfWeek: 3, startTime: 20 * 60 },
    { dayOfWeek: 5, startTime: 10 * 60 },
  ];
  let slotIndex = 0;

  return params.materials.flatMap((material) => {
    const deadline = parseISO(material.deadline);
    const daysToDeadline = differenceInCalendarDays(deadline, weekStartDate);
    if (Number.isNaN(daysToDeadline) || daysToDeadline < 0) return [];

    const sessions = daysToDeadline <= 14 ? 2 : 1;
    return Array.from({ length: sessions }).map((_, idx) => {
      const slot = slots[slotIndex % slots.length];
      slotIndex += 1;
      return {
        id: `auto_${params.weekId}_${material.id}_${idx}`,
        weekId: params.weekId,
        type: 'study',
        dayOfWeek: slot.dayOfWeek,
        startTime: slot.startTime,
        duration: 60,
        categoryId: material.categoryId,
        materialId: material.id,
        label: material.name,
        status: 'planned',
        isAutoGenerated: true,
      } satisfies PlanItem;
    });
  });
}

export function WeeklyPlanPage({
  data,
  period,
  onChangePeriod,
  onUpdateData,
  onNavigateSettings,
  onNavigateMaterials,
}: {
  data: AppData;
  period: PeriodValue;
  onChangePeriod: (next: PeriodValue) => void;
  onUpdateData: (updater: (prev: AppData) => AppData) => void;
  onNavigateSettings: () => void;
  onNavigateMaterials: () => void;
}) {
  const weekId = weekIdFromStart(period.start);
  const week = data.planWeeks.find((w) => w.weekStartDate === period.start);
  const weekItems = useMemo(() => data.planItems.filter((item) => item.weekId === weekId), [data.planItems, weekId]);
  const weekLifestyleOverrides = useMemo(
    () => weekItems.filter((item) => item.type !== 'study'),
    [weekItems],
  );
  const hasWeekLifestyleOverride = weekLifestyleOverrides.length > 0;
  const studyItems = weekItems.filter((item) => item.type === 'study');
  const doneItems = studyItems.filter((item) => item.status === 'done');
  const autoItems = weekItems.filter((item) => item.isAutoGenerated && item.type === 'study');
  const defaultGoals = useMemo(() => createDefaultWeeklyGoals(), [period.start]);
  const weekGoals = week?.goals ?? defaultGoals;

  const baseLifestyleTemplate = useMemo(
    () => data.lifestyleTemplate ?? createDefaultLifestyleTemplate(),
    [data.lifestyleTemplate],
  );
  const weekLifestyleTemplate = useMemo(() => {
    if (hasWeekLifestyleOverride) {
      return buildTemplateFromWeekItems(weekLifestyleOverrides, baseLifestyleTemplate);
    }
    return data.lifestyleTemplate;
  }, [hasWeekLifestyleOverride, weekLifestyleOverrides, baseLifestyleTemplate, data.lifestyleTemplate]);
  const lifestyleReady = Boolean(
    weekLifestyleTemplate &&
      weekLifestyleTemplate.weekdaySleep &&
      weekLifestyleTemplate.weekdaySleep.startTime !== weekLifestyleTemplate.weekdaySleep.endTime,
  );
  const lifestyleItems = weekLifestyleTemplate ? buildLifestyleItems(weekId, weekLifestyleTemplate) : [];
  const displayLifestyleItems = hasWeekLifestyleOverride ? weekLifestyleOverrides : lifestyleItems;
  const displayItems = lifestyleReady ? [...displayLifestyleItems, ...studyItems] : studyItems;

  const availableMinutes = hasWeekLifestyleOverride
    ? computeAvailableMinutesFromItems(displayLifestyleItems)
    : computeAvailableMinutes(weekLifestyleTemplate);
  const doneMinutes = doneItems.reduce((sum, item) => sum + (item.actualDuration ?? item.duration), 0);
  const plannedMinutes = studyItems.reduce((sum, item) => sum + item.duration, 0);

  const doneCategoryTotals = computeCategoryTotals(doneItems);
  const plannedCategoryTotals = new Map<string, number>();
  studyItems.forEach((item) => {
    if (!item.categoryId) return;
    plannedCategoryTotals.set(item.categoryId, (plannedCategoryTotals.get(item.categoryId) ?? 0) + item.duration);
  });
  const categorySummary = Array.from(plannedCategoryTotals.entries())
    .map(([categoryId, planned]) => ({
      category: data.categories.find((c) => c.id === categoryId),
      planned,
      done: doneCategoryTotals.get(categoryId) ?? 0,
    }))
    .filter((entry) => entry.category)
    .sort((a, b) => b.planned - a.planned);

  const remainingMinutes = Math.max(0, availableMinutes - doneMinutes);
  const todayIndex = useMemo(() => {
    const jsDay = new Date().getDay();
    return (jsDay + 6) % 7;
  }, []);
  const todayStudyItems = studyItems.filter((item) => item.dayOfWeek === todayIndex);
  const todaySchedule = [...todayStudyItems].sort((a, b) => a.startTime - b.startTime);
  const todayPlannedMinutes = todayStudyItems.reduce((sum, item) => sum + item.duration, 0);

  const now = new Date();
  const nowMinutes = now.getHours() * 60 + now.getMinutes();
  const nextScheduledItem = todayStudyItems
    .filter((item) => item.status !== 'done' && item.startTime >= nowMinutes)
    .sort((a, b) => a.startTime - b.startTime)[0];

  const [showCategoryDetail, setShowCategoryDetail] = useState(false);
  const [itemDialogOpen, setItemDialogOpen] = useState(false);
  const [editingItem, setEditingItem] = useState<
    (Partial<PlanItem> & Pick<PlanItem, 'dayOfWeek' | 'startTime' | 'duration'>) | null
  >(null);
  const [autoDialogOpen, setAutoDialogOpen] = useState(false);
  const [autoMode, setAutoMode] = useState<AutoGenerateMode>('append');
  const [setupOpen, setSetupOpen] = useState(false);
  const [lifestyleDraft, setLifestyleDraft] = useState<LifestyleTemplate>(baseLifestyleTemplate);
  const [lifestyleItemOpen, setLifestyleItemOpen] = useState(false);
  const [editingLifestyleItem, setEditingLifestyleItem] = useState<PlanItem | null>(null);
  const [lifestyleStart, setLifestyleStart] = useState('00:00');
  const [lifestyleEnd, setLifestyleEnd] = useState('00:00');
  const [lifestyleLabel, setLifestyleLabel] = useState('');
  const [lifestyleCategoryId, setLifestyleCategoryId] = useState('none');

  useEffect(() => {
    if (!setupOpen) return;
    if (weekLifestyleTemplate) {
      setLifestyleDraft(weekLifestyleTemplate);
      return;
    }
    setLifestyleDraft(baseLifestyleTemplate);
  }, [setupOpen, weekLifestyleTemplate, baseLifestyleTemplate]);

  useEffect(() => {
    if (!editingLifestyleItem) return;
    setLifestyleStart(minutesToTimeString(editingLifestyleItem.startTime));
    setLifestyleEnd(minutesToTimeString((editingLifestyleItem.startTime + editingLifestyleItem.duration) % 1440));
    setLifestyleLabel(
      editingLifestyleItem.type === 'fixed'
        ? editingLifestyleItem.label ?? '固定予定'
        : editingLifestyleItem.label ?? '睡眠',
    );
    setLifestyleCategoryId(editingLifestyleItem.categoryId ?? 'none');
  }, [editingLifestyleItem]);

  const ensureWeek = (prev: AppData): { next: AppData; week: PlanWeek } => {
    const existing = prev.planWeeks.find((w) => w.weekStartDate === period.start);
    if (existing) return { next: prev, week: existing };
    const now = new Date().toISOString();
    const nextWeek: PlanWeek = {
      id: weekId,
      weekStartDate: period.start,
      weekEndDate: period.end,
      createdAt: now,
      updatedAt: now,
      goals: defaultGoals,
    };
    return { next: { ...prev, planWeeks: [nextWeek, ...prev.planWeeks] }, week: nextWeek };
  };

  const touchWeek = (weeks: PlanWeek[], targetId: string) => {
    const now = new Date().toISOString();
    return weeks.map((w) => (w.id === targetId ? { ...w, updatedAt: now } : w));
  };

  const updateWeekGoals = (updater: (prevGoals: WeeklyGoal[]) => WeeklyGoal[]) => {
    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const currentGoals = ensured.week.goals ?? defaultGoals;
      const nextGoals = updater(currentGoals);
      const now = new Date().toISOString();
      return {
        ...ensured.next,
        planWeeks: ensured.next.planWeeks.map((w) =>
          w.id === ensured.week.id ? { ...w, goals: nextGoals, updatedAt: now } : w,
        ),
      };
    });
  };

  const handleGoalChange = (goalId: string, text: string) => {
    updateWeekGoals((prevGoals) => prevGoals.map((goal) => (goal.id === goalId ? { ...goal, text } : goal)));
  };

  const handleGoalToggle = (goalId: string) => {
    updateWeekGoals((prevGoals) =>
      prevGoals.map((goal) => (goal.id === goalId ? { ...goal, completed: !goal.completed } : goal)),
    );
  };

  const handleGoalAdd = () => {
    updateWeekGoals((prevGoals) => [
      ...prevGoals,
      {
        id: `goal_${Date.now()}`,
        text: '',
        completed: false,
      },
    ]);
  };

  const handleGoalDelete = (goalId: string) => {
    updateWeekGoals((prevGoals) => prevGoals.filter((goal) => goal.id !== goalId));
  };

  const openNewItemDialog = () => {
    if (!lifestyleReady) {
      setSetupOpen(true);
      return;
    }
    setEditingItem(null);
    setItemDialogOpen(true);
  };

  const openLifestyleItemDialog = (item: PlanItem) => {
    setEditingLifestyleItem(item);
    setLifestyleItemOpen(true);
  };

  const handleSaveItem = (item: PlanItem) => {
    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const nextItem = { ...item, weekId: ensured.week.id };
      const exists = prev.planItems.some((i) => i.id === nextItem.id);
      const nextItems = exists
        ? prev.planItems.map((i) => (i.id === nextItem.id ? nextItem : i))
        : [...prev.planItems, nextItem];

      return {
        ...ensured.next,
        planItems: nextItems,
        planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
        lastUsedCategoryId: nextItem.categoryId ?? prev.lastUsedCategoryId,
      };
    });
    toast.success('学習ブロックを保存しました');
  };

  const handleSaveLifestyleItem = () => {
    if (!editingLifestyleItem) return;
    const startTime = timeStringToMinutes(lifestyleStart);
    const endTime = timeStringToMinutes(lifestyleEnd);
    const duration = getLifestyleDurationMinutes(startTime, endTime);
    if (duration <= 0) {
      toast.error('開始と終了を正しく設定してください');
      return;
    }

    const nextItem: PlanItem = {
      ...editingLifestyleItem,
      startTime,
      duration,
      label:
        editingLifestyleItem.type === 'fixed'
          ? lifestyleLabel.trim() || '固定予定'
          : editingLifestyleItem.label ?? '睡眠',
      categoryId:
        editingLifestyleItem.type === 'fixed'
          ? lifestyleCategoryId === 'none'
            ? undefined
            : lifestyleCategoryId
          : editingLifestyleItem.categoryId,
    };

    handleUpdateItem(nextItem);
    toast.success('予定を更新しました');
    setLifestyleItemOpen(false);
    setEditingLifestyleItem(null);
  };

  const handleUpdateItem = (item: PlanItem) => {
    if (item.type !== 'study') {
      onUpdateData((prev) => {
        const ensured = ensureWeek(prev);
        const baseItems = getWeekLifestyleItemsFromData(prev, ensured.week.id);
        const exists = baseItems.some((base) => base.id === item.id);
        const nextLifestyleItems = exists
          ? baseItems.map((base) => (base.id === item.id ? { ...item, weekId: ensured.week.id } : base))
          : [...baseItems, { ...item, weekId: ensured.week.id }];
        const filtered = prev.planItems.filter(
          (current) => current.weekId !== ensured.week.id || current.type === 'study',
        );
        return {
          ...ensured.next,
          planItems: [...filtered, ...nextLifestyleItems],
          planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
        };
      });
      return;
    }

    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const exists = prev.planItems.some((i) => i.id === item.id);
      const nextItems = exists
        ? prev.planItems.map((i) => (i.id === item.id ? { ...item, weekId: ensured.week.id } : i))
        : [...prev.planItems, { ...item, weekId: ensured.week.id }];
      return {
        ...ensured.next,
        planItems: nextItems,
        planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
      };
    });
  };

  const handleMarkDone = (item: PlanItem) => {
    handleUpdateItem({ ...item, status: 'done' });
  };

  const deleteItemWithUndo = (item: PlanItem) => {
    onUpdateData((prev) => ({
      ...prev,
      planItems: prev.planItems.filter((existing) => existing.id !== item.id),
    }));
    toast.message('学習ブロックを削除しました', {
      action: {
        label: '元に戻す',
        onClick: () => {
          onUpdateData((prev) => {
            if (prev.planItems.some((existing) => existing.id === item.id)) {
              return prev;
            }
            return {
              ...prev,
              planItems: [...prev.planItems, item],
            };
          });
        },
      },
    });
  };

  const handleDeleteItem = () => {
    if (!editingItem?.id) return;
    const target = weekItems.find((item) => item.id === editingItem.id) ?? (editingItem as PlanItem);
    deleteItemWithUndo(target);
    setEditingItem(null);
  };

  const handleDeleteItemById = (item: PlanItem) => {
    if (item.type !== 'study') {
      onUpdateData((prev) => {
        const ensured = ensureWeek(prev);
        const baseItems = getWeekLifestyleItemsFromData(prev, ensured.week.id);
        const nextLifestyleItems = baseItems.filter((base) => base.id !== item.id);
        const filtered = prev.planItems.filter(
          (current) => current.weekId !== ensured.week.id || current.type === 'study',
        );
        return {
          ...ensured.next,
          planItems: [...filtered, ...nextLifestyleItems],
          planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
        };
      });
      toast.message('この週の生活時間を更新しました');
      return;
    }
    deleteItemWithUndo(item);
  };

  const handleAutoGenerate = (mode: AutoGenerateMode) => {
    if (data.materials.length === 0) {
      toast.message('教材が登録されていません。先に教材を追加してください。');
      onNavigateMaterials();
      return;
    }

    onUpdateData((prev) => {
      const ensured = ensureWeek(prev);
      const newAutoItems = generateAutoItems({ weekStart: period.start, weekId: ensured.week.id, materials: prev.materials });
      const filtered = mode === 'replace'
        ? prev.planItems.filter(
            (item) =>
              item.weekId !== ensured.week.id ||
              item.type !== 'study' ||
              !item.isAutoGenerated,
          )
        : prev.planItems;
      return {
        ...ensured.next,
        planItems: [...filtered, ...newAutoItems],
        planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
      };
    });
    toast.success(mode === 'replace' ? '自動タスクを再生成しました' : '自動タスクを追加しました');
  };

  const weekSlotCount = studyItems.length;
  const todaySlotCount = todayStudyItems.length;
  const nextLabel = nextScheduledItem
    ? `次: 今日 ${minutesToTimeString(nextScheduledItem.startTime)}〜${formatMinutes(nextScheduledItem.duration)}`
    : '';

  return (
    <AppChrome
      title="週計画"
      actions={null}
    >
      <PageLayout>
        <PageHeader title="週計画" description={undefined} action={null} />

        <Card className="bg-white shadow-sm">
          <CardContent className="py-3">
            <div className="flex flex-wrap items-center gap-4">
              <div className="flex items-center gap-2 text-xs text-slate-500">
                <Calendar className="w-4 h-4 text-slate-400" />
                <PeriodSelector value={period} onChange={onChangePeriod} mode="week" weekStartsOn={1} />
                <span>{formatPeriod(period.start, period.end)}</span>
              </div>
              <div className="ml-auto flex flex-wrap items-center gap-2 text-xs">
                <div className="flex items-center gap-2 rounded-full border border-slate-200 bg-slate-50 px-3 py-1 text-slate-600">
                  <span className="text-[11px] text-slate-400">今週</span>
                  <span className="font-medium text-slate-900">{weekSlotCount}コマ</span>
                  <span className="text-slate-400">/</span>
                  <span className="font-medium text-slate-900">{formatMinutes(plannedMinutes)}</span>
                </div>
                <div className="flex items-center gap-2 rounded-full border border-slate-200 bg-slate-50 px-3 py-1 text-slate-600">
                  <span className="text-[11px] text-slate-400">今日</span>
                  <span className="font-medium text-slate-900">{todaySlotCount}コマ</span>
                  <span className="text-slate-400">/</span>
                  <span className="font-medium text-slate-900">{formatMinutes(todayPlannedMinutes)}</span>
                </div>
                {nextLabel ? (
                  <div className="flex items-center gap-2 rounded-full border border-indigo-200 bg-indigo-50 px-3 py-1 text-indigo-700 shadow-sm">
                    <span className="text-[11px] text-indigo-500">次</span>
                    <span className="font-semibold">{nextLabel.replace('次: ', '')}</span>
                  </div>
                ) : null}
              </div>
            </div>
            <ScheduleStrip
              items={todaySchedule.map((item) => {
                const startLabel = minutesToTimeString(item.startTime);
                const endLabel = minutesToTimeString(item.startTime + item.duration);
                const category = data.categories.find((c) => c.id === item.categoryId)?.name ?? '学習';
                const material = data.materials.find((m) => m.id === item.materialId)?.name;
                const title = item.label ?? material ?? category;
                const isCurrent =
                  item.status !== 'done' &&
                  nowMinutes >= item.startTime &&
                  nowMinutes < item.startTime + item.duration;
                return {
                  id: item.id,
                  start: startLabel,
                  end: endLabel,
                  title,
                  category,
                  minutes: item.duration,
                  status: item.status === 'done' ? 'done' : isCurrent ? 'current' : 'upcoming',
                };
              })}
              onMarkDone={(id) => {
                const target = todaySchedule.find((item) => item.id === id);
                if (target) handleMarkDone(target);
              }}
            />
          </CardContent>
        </Card>

        <div className="grid gap-6 lg:grid-cols-[minmax(0,1fr)_360px] lg:items-start">
          <div id="weekly-timetable" className={cn('order-1 lg:order-none space-y-3')}>
            <div className="flex flex-wrap items-center justify-between gap-3">
              <div className="space-y-1">
                <h2 className="text-base font-medium text-slate-900">今日は、どこに入れる？</h2>
                <div className="flex flex-wrap items-center gap-2 text-xs text-slate-500">
                  <span>空き枠をクリックして予定を追加できます</span>
                </div>
              </div>
              <div className="flex flex-wrap items-center gap-2">
                <Button variant="outline" size="sm" className="bg-white" onClick={onNavigateSettings}>
                  生活時間を編集
                </Button>
                <Button
                  variant="outline"
                  size="sm"
                  className="bg-white"
                  onClick={() => setAutoDialogOpen(true)}
                  disabled={!lifestyleReady || autoItems.length === 0}
                >
                  <RefreshCcw className="w-4 h-4 mr-2" />
                  再生成
                </Button>
              </div>
            </div>
            <PlanTimeTable
              items={displayItems}
              categories={data.categories}
              materials={data.materials}
              editable={lifestyleReady}
              allowLifestyleEdit
              onLifestyleEdit={openLifestyleItemDialog}
              onItemChange={handleUpdateItem}
              onItemDelete={handleDeleteItemById}
              onItemClick={(item) => {
                setEditingItem(item);
                setItemDialogOpen(true);
              }}
              onEmptySlotClick={(dayOfWeek, startTime) => {
                if (!lifestyleReady) {
                  setSetupOpen(true);
                  return;
                }
                setEditingItem({
                  weekId,
                  type: 'study',
                  dayOfWeek,
                  startTime,
                  duration: 30,
                  status: 'planned',
                });
                setItemDialogOpen(true);
              }}
              onRangeSelect={(dayOfWeek, startTime, duration) => {
                if (!lifestyleReady) {
                  setSetupOpen(true);
                  return;
                }
                setEditingItem({
                  weekId,
                  type: 'study',
                  dayOfWeek,
                  startTime,
                  duration,
                  status: 'planned',
                });
                setItemDialogOpen(true);
              }}
            />
          </div>

          <aside className="order-2 lg:order-none space-y-4">
            <div id="weekly-goals">
              <GoalsSection
                goals={weekGoals}
                editable
                onGoalChange={handleGoalChange}
                onGoalToggle={handleGoalToggle}
                onGoalAdd={handleGoalAdd}
                onGoalDelete={handleGoalDelete}
              />
            </div>

            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm text-slate-600">残り</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                <div>
                  <p className="text-[11px] text-slate-500">残りの目安</p>
                  <p className={cn('text-base font-semibold', !lifestyleReady ? 'text-slate-500' : 'text-slate-900')}>
                    {lifestyleReady ? formatMinutes(remainingMinutes) : '未設定'}
                  </p>
                </div>
                <div className="grid gap-2">
                  <div className="flex items-center justify-between text-xs text-slate-500">
                    <span>今週の目標</span>
                    <span className="font-mono text-slate-700">
                      {plannedMinutes === 0 ? '未設定' : formatMinutes(plannedMinutes)}
                    </span>
                  </div>
                  <div className="flex items-center justify-between text-xs text-slate-500">
                    <span>今週の実績</span>
                    <span className="font-mono text-slate-700">
                      {doneMinutes === 0 ? '未記録' : formatMinutes(doneMinutes)}
                    </span>
                  </div>
                </div>
              </CardContent>
            </Card>

            {studyItems.length === 0 ? (
              <EmptyState
                icon={<Calendar className="w-5 h-5" />}
                title="今週の予定がまだありません"
                description="まずは学習ブロックを追加して、今週の流れを作りましょう。"
                actions={[
                  { label: '学習ブロックを追加', onClick: openNewItemDialog },
                  { label: '教材から割り当て', onClick: onNavigateMaterials, variant: 'outline' },
                ]}
              />
            ) : null}

            <Card>
              <CardHeader className="pb-2 flex flex-row items-center justify-between">
                <CardTitle className="text-sm text-slate-600">内訳</CardTitle>
                <Button variant="ghost" size="sm" onClick={() => setShowCategoryDetail((v) => !v)}>
                  {showCategoryDetail ? '閉じる' : 'もっと見る'}
                </Button>
              </CardHeader>
              <CardContent className="space-y-3">
                {categorySummary.length === 0 ? (
                  <div className="rounded-xl border border-dashed border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-500">
                    まだ記録はありません。学習を完了すると内訳が表示されます。
                  </div>
                ) : (
                  <div className="space-y-3">
                    {categorySummary.slice(0, 3).map((entry) => {
                      const ratio = entry.planned > 0 ? Math.min(1, entry.done / entry.planned) : 0;
                      const fillClass =
                        entry.category?.color
                          ?.split(' ')
                          .find((item) => item.startsWith('bg-')) ?? 'bg-slate-200';
                      return (
                        <div key={entry.category?.id} className="space-y-1">
                          <div className="flex items-center justify-between text-xs text-slate-500">
                            <div className="flex items-center gap-2">
                              {entry.category ? (
                                <Badge variant="outline" className={entry.category.color}>
                                  {entry.category.name}
                                </Badge>
                              ) : null}
                              <span>実績 {formatMinutes(entry.done)}</span>
                            </div>
                            <span className="font-mono">{formatMinutes(entry.planned)}</span>
                          </div>
                          <div className="h-2 rounded-full bg-slate-100">
                            <div className={cn('h-2 rounded-full', fillClass)} style={{ width: `${ratio * 100}%` }} />
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
                {showCategoryDetail && categorySummary.length > 0 && (
                  <div className="pt-3 border-t border-slate-100 space-y-3 max-h-[320px] overflow-auto">
                    {categorySummary.map((entry) => {
                      const ratio = entry.planned > 0 ? Math.min(1, entry.done / entry.planned) : 0;
                      const fillClass =
                        entry.category?.color
                          ?.split(' ')
                          .find((item) => item.startsWith('bg-')) ?? 'bg-slate-200';
                      return (
                        <div key={entry.category?.id} className="space-y-1">
                          <div className="flex items-center justify-between text-xs text-slate-500">
                            <div className="flex items-center gap-2">
                              {entry.category ? (
                                <Badge variant="outline" className={entry.category.color}>
                                  {entry.category.name}
                                </Badge>
                              ) : null}
                              <span>実績 {formatMinutes(entry.done)}</span>
                            </div>
                            <span className="font-mono">{formatMinutes(entry.planned)}</span>
                          </div>
                          <div className="h-2 rounded-full bg-slate-100">
                            <div className={cn('h-2 rounded-full', fillClass)} style={{ width: `${ratio * 100}%` }} />
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </CardContent>
            </Card>

            <Card>
              <CardHeader className="pb-2">
                <CardTitle className="text-sm text-slate-600">未完了予定</CardTitle>
              </CardHeader>
              <CardContent className="space-y-3">
                {studyItems.filter((item) => item.status !== 'done').length === 0 ? (
                  <div className="rounded-xl border border-dashed border-slate-200 bg-slate-50 px-3 py-2 text-xs text-slate-500">
                    未完了の予定はありません。
                  </div>
                ) : (
                  <div className="space-y-2 max-h-[260px] overflow-auto pr-1">
                    {studyItems
                      .filter((item) => item.status !== 'done')
                      .sort((a, b) => (a.dayOfWeek - b.dayOfWeek) || (a.startTime - b.startTime))
                      .map((item) => {
                        const dayLabel = ['月', '火', '水', '木', '金', '土', '日'][item.dayOfWeek];
                        const startLabel = minutesToTimeString(item.startTime);
                        const endLabel = minutesToTimeString(item.startTime + item.duration);
                        const label = item.label ?? data.categories.find((c) => c.id === item.categoryId)?.name ?? '学習';
                        return (
                          <div key={item.id} className="flex items-center justify-between gap-3 text-xs text-slate-700">
                            <div className="flex items-center gap-2 min-w-0">
                              <span className="rounded-full bg-slate-100 px-2 py-0.5 text-[10px] text-slate-500">
                                {dayLabel}
                              </span>
                              <span className="font-mono text-slate-500">{startLabel}-{endLabel}</span>
                              <span className="truncate text-slate-900">{label}</span>
                            </div>
                            <Button
                              type="button"
                              variant="outline"
                              size="sm"
                              className="h-7 px-2 text-xs bg-white"
                              onClick={() => handleMarkDone(item)}
                            >
                              完了にする
                            </Button>
                          </div>
                        );
                      })}
                  </div>
                )}
              </CardContent>
            </Card>
          </aside>
        </div>
      </PageLayout>

      <PlanItemDialog
        open={itemDialogOpen}
        onOpenChange={(open) => {
          setItemDialogOpen(open);
          if (!open) setEditingItem(null);
        }}
        categories={data.categories}
        materials={data.materials}
        initial={
          editingItem ?? {
            dayOfWeek: 0,
            startTime: 19 * 60,
            duration: 60,
            status: 'planned',
          }
        }
        defaultCategoryId={data.lastUsedCategoryId ?? data.categories[0]?.id}
        onSave={handleSaveItem}
        onDelete={editingItem?.id ? handleDeleteItem : undefined}
      />

      <Dialog
        open={lifestyleItemOpen}
        onOpenChange={(open) => {
          setLifestyleItemOpen(open);
          if (!open) setEditingLifestyleItem(null);
        }}
      >
        <DialogContent className="sm:max-w-[520px]">
          <DialogHeader>
            <DialogTitle>生活時間を編集</DialogTitle>
            <DialogDescription>この予定だけを変更します。</DialogDescription>
          </DialogHeader>
          {editingLifestyleItem ? (
            <div className="space-y-4">
              <div className="grid gap-3 sm:grid-cols-2">
                <div className="space-y-1">
                  <Label>曜日</Label>
                  <div className="rounded-md border border-slate-200 bg-slate-50 px-3 py-2 text-sm text-slate-700">
                    {DAYS.find((day) => day.value === editingLifestyleItem.dayOfWeek)?.label ?? ''}
                  </div>
                </div>
                <div className="space-y-1">
                  <Label>種別</Label>
                  <div className="rounded-md border border-slate-200 bg-slate-50 px-3 py-2 text-sm text-slate-700">
                    {editingLifestyleItem.type === 'fixed' ? '固定予定' : '睡眠'}
                  </div>
                </div>
              </div>

              <div className="grid gap-3 sm:grid-cols-2">
                <div className="space-y-1">
                  <Label htmlFor="lifestyle-start">開始</Label>
                  <Input
                    id="lifestyle-start"
                    type="time"
                    value={lifestyleStart}
                    onChange={(event) => setLifestyleStart(event.target.value)}
                  />
                </div>
                <div className="space-y-1">
                  <Label htmlFor="lifestyle-end">終了</Label>
                  <Input
                    id="lifestyle-end"
                    type="time"
                    value={lifestyleEnd}
                    onChange={(event) => setLifestyleEnd(event.target.value)}
                  />
                </div>
              </div>

              {editingLifestyleItem.type === 'fixed' ? (
                <div className="grid gap-3 sm:grid-cols-2">
                  <div className="space-y-1">
                    <Label htmlFor="lifestyle-label">ラベル</Label>
                    <Input
                      id="lifestyle-label"
                      value={lifestyleLabel}
                      onChange={(event) => setLifestyleLabel(event.target.value)}
                      placeholder="例: 昼休憩"
                    />
                  </div>
                  <div className="space-y-1">
                    <Label>カテゴリ</Label>
                    <Select value={lifestyleCategoryId} onValueChange={setLifestyleCategoryId}>
                      <SelectTrigger>
                        <SelectValue placeholder="カテゴリを選択" />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="none">カテゴリなし</SelectItem>
                        {data.categories.map((category) => (
                          <SelectItem key={category.id} value={category.id}>
                            {category.name}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                </div>
              ) : null}

              <p className="text-xs text-slate-500">終了が開始より前の場合は翌日扱いになります。</p>
            </div>
          ) : null}
          <DialogFooter className="gap-2">
            <Button
              variant="outline"
              className="bg-white"
              onClick={() => {
                setLifestyleItemOpen(false);
                setEditingLifestyleItem(null);
              }}
            >
              キャンセル
            </Button>
            <Button onClick={handleSaveLifestyleItem}>保存</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={autoDialogOpen} onOpenChange={setAutoDialogOpen}>
        <DialogContent className="sm:max-w-[420px]">
          <DialogHeader>
            <DialogTitle>自動生成の方法を選択</DialogTitle>
            <DialogDescription>
              既存の自動タスクを置き換えるか、追加で生成するかを選べます。手動で作ったブロックは維持されます。
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-2">
            <label className="flex items-center gap-2 text-sm text-slate-700">
              <input
                type="radio"
                name="autoMode"
                value="append"
                checked={autoMode === 'append'}
                onChange={() => setAutoMode('append')}
              />
              追加する（既存の自動タスクは残す）
            </label>
            <label className="flex items-center gap-2 text-sm text-slate-700">
              <input
                type="radio"
                name="autoMode"
                value="replace"
                checked={autoMode === 'replace'}
                onChange={() => setAutoMode('replace')}
              />
              置き換える（既存の自動タスクを削除して再生成）
            </label>
          </div>
          <DialogFooter className="gap-2">
            <Button variant="outline" className="bg-white" onClick={() => setAutoDialogOpen(false)}>
              キャンセル
            </Button>
            <Button
              onClick={() => {
                handleAutoGenerate(autoMode);
                setAutoDialogOpen(false);
              }}
            >
              実行
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      <Dialog open={setupOpen} onOpenChange={setSetupOpen}>
        <DialogContent className="sm:max-w-[640px]">
          <DialogHeader>
            <DialogTitle>この週の生活時間を編集</DialogTitle>
            <DialogDescription>
              変更内容はこの週だけに反映されます。
            </DialogDescription>
          </DialogHeader>
          <LifestyleForm value={lifestyleDraft} categories={data.categories} onChange={setLifestyleDraft} />
          <DialogFooter className="gap-2">
            <Button variant="outline" className="bg-white" onClick={() => setSetupOpen(false)}>
              キャンセル
            </Button>
            <Button
              onClick={() => {
                if (lifestyleDraft.weekdaySleep.startTime === lifestyleDraft.weekdaySleep.endTime) {
                  toast.error('平日の睡眠時間を正しく設定してください');
                  return;
                }
                onUpdateData((prev) => {
                  const ensured = ensureWeek(prev);
                  const overrideItems = buildLifestyleItems(ensured.week.id, {
                    ...lifestyleDraft,
                    updatedAt: new Date().toISOString(),
                  });
                  const filtered = prev.planItems.filter(
                    (item) => item.weekId !== ensured.week.id || item.type === 'study',
                  );
                  return {
                    ...ensured.next,
                    planItems: [...filtered, ...overrideItems],
                    planWeeks: touchWeek(ensured.next.planWeeks, ensured.week.id),
                  };
                });
                toast.success('この週の生活時間を保存しました');
                setSetupOpen(false);
              }}
            >
              保存
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </AppChrome>
  );
}
